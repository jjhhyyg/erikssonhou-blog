---
date: 2025-10-27
title: 2. 变量和基本类型
description: 介绍了 C++ 的内置类型，了解 C++ 复杂数据类型
---

## 2.1 基本内置类型

### 2.1.1 算术类型

算术类型分为两类：整型和浮点型。

算术类型的尺寸在不同机器上有所差别。下表列出了 C++ 标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。

| Type        | Meaning                           | Minimum Size          |
| ----------- | --------------------------------- | --------------------- |
| bool        | Boolean                           | N/A                   |
| char        | Character                         | 8 bits                |
| wchar_t     | Wide character                    | 16 bits               |
| char16_t    | Unicode character                 | 16 bits               |
| char32_t    | Unicode character                 | 32 bits               |
| short       | Short integer                     | 16 bits               |
| int         | Integer                           | 16 bits               |
| long        | Long integer                      | 32 bits               |
| long long   | Long integer                      | 64 bits               |
| float       | Single-precision floating-point   | 6 significant digits  |
| double      | Double-precision floating-point   | 10 significant digits |
| long double | Extended-precision floating-point | 10 significant digits |

#### 字符类型

- 字符类型有多种，其中大多数是为了支持国际化而存在的。基本字符类型是 `char`。`char` 的大小保证足以容纳与机器基本字符集中的字符对应的数值。也就是说，`char` 的大小与**单个机器字节**相同。
- 其余字符类型——`wchar_t`、`char16_t` 和 `char32_t` ——用于扩展字符集。`wchar_t` 类型保证足够大，可以容纳机器最大扩展字符集中的任何字符。`char16_t` 和 `char32_t` 类型用于 `Unicode 字符`。

#### 其他整型

其余的整数类型表示（可能）不同大小的整数值。C++ 语言保证：

- int 至少与 short 大小相同
- long 至少与 int 大小相同
- long long 至少与 long 大小相同
- long long 类型是 C++ 11 标准引入的

#### 浮点类型

浮点类型表示单精度、双精度和扩展精度值。C++ 标准规定了有效数字的最小位数。大多数编译器提供的精度高于规定的最小值。通常：

- 浮点数（float）用一个字（32 位）表示
- 双精度数（double）用两个字（64 位）表示
- 长双精度数（long double）用三个或四个字（96 位或 128 位）表示

浮点数和双精度数通常分别产生约 7 位和 16 位有效数字。长双精度数通常用于兼容专用浮点硬件；其精度在不同实现之间可能存在差异。

#### 带符号类型和无符号类型

除去布尔型和扩展的字符型之外，其他整型可以划分为**带符号的（signed）** 和 **无符号的（unsigned）**。

与其他整型不同，字符型被划分为了三种：char、signed char 和 unsigned char。尽管字符型有三种，但字符的表现形式只有两种：带符号的和无符号的。类型 char 实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。

#### 建议：如何选择类型

- 当明确知晓数值不可能为负时，选用无符号类型；
- 使用int执行整数运算。如果数值超过了int的表示范围，选用long long；
- 在**算术表达式**中不要使用char或bool，如果需要一个不大的整数，要明确指定它的类型是signed char/unsigned char；
- 执行浮点运算用double，float和double的计算代价相差无几，对某些机器来说，double运算速度比float还快。

#### 练习

##### 2.1 类型int、long、long long和 short 的区别是什么？无符号类型和带符号类型的区别是什么？float 和 double 的区别是什么？

*我的回答*

1. int 至少与 short 大小相同；long 至少与 int 大小相同；long long 至少与 long 大小相同
2. 无符号类型大于等于0，带符号类型可小于、等于和大于0
3. float用一个字表示，double用两个字表示；float有效数位为7，double有效数位为17

*Claude修正后的回答*

1. int、long、long long 和 short 的区别

    **C++标准保证的最小尺寸要求：**

    - `short` 至少16位（2字节）
    - `int` 至少16位（2字节）
    - `long` 至少32位（4字节）
    - `long long` 至少64位（8字节）（C++11引入）

    **尺寸关系保证：**

    ```plaintext
    short ≤ int ≤ long ≤ long long
    ```

    **常见实现（取决于平台）：**

    - 32位系统：`short`(2字节)，`int`(4字节)，`long`(4字节)，`long long`(8字节)
    - 64位系统：`short`(2字节)，`int`(4字节)，`long`(4或8字节)，`long long`(8字节)

2. 无符号类型和带符号类型的区别

   - **带符号类型（signed）**：可以表示负数、零和正数，最高位为符号位
   - **无符号类型（unsigned）**：只能表示零和正数（≥0），所有位都用于表示数值

   **关键区别：**

   - 相同字节数下，无符号类型能表示的最大正数约为带符号类型的两倍
   - 例如：`unsigned int`(0 到 4,294,967,295) vs `int`(-2,147,483,648 到 2,147,483,647)

3. float 和 double 的区别

    | 特性             | float               | double                |
    | ---------------- | ------------------- | --------------------- |
    | **存储大小**     | 4字节（32位）       | 8字节（64位）         |
    | **有效数字位数** | 约6-7位十进制数字   | 约15-16位十进制数字   |
    | **精度**         | 单精度              | 双精度                |
    | **指数范围**     | 约10^(-38)到10^(38) | 约10^(-308)到10^(308) |

    **术语说明：**

    - "字（word）"是一个与处理器架构相关的概念，在不同系统上大小不同
    - 更准确的表述应使用"字节（byte）"作为单位

    **建议：**

    - 一般情况下优先使用`double`，因为精度更高且现代处理器对double的运算效率与float相当
    - 只在内存受限或需要大量浮点数存储时考虑使用`float`

##### 2.2 计算按揭贷款时，对千利率、本金和付款分别应选择何种数据类型？说明你的理由

1. 利率：double

    - 利率为小数（如0.0525或5.25%）
    - 需要较高精度避免复利计算中的累积误差

2. 本金：double

    - 金额可能有小数（精确到分）
    - 数值范围在double表示范围内
    - 需要与利率进行浮点运算

3. 付款：double

    - 月供金额通常有小数
    - 由本金和利率计算得出，保持类型一致避免转换
    - 便于后续财务计算

### 2.1.2 类型转换

#### 转换准则

- 当我们将一个**非布尔值**的算术类型赋给一个 `bool` 对象时，如果原值是 0，则结果为 `false`，否则为 `true`。
- 当我们将一个 `bool` 值赋给一个**非 `bool` 值**的算术类型时，如果 `bool` 值为 `true`，则结果为 1，如果为 `false`，则结果为 0。
- 当我们将一个**浮点型**值赋给一个**整型**对象时，该值会被**截断** (truncated)。存储的值是小数点前的部分。
- 当我们将一个**整型**值赋给一个**浮点型**对象时，小数部分为零。如果该整数的位数（比特）超过了浮点型对象所能容纳的范围，可能会**损失精度**。
- 如果我们给一个**无符号类型** (unsigned) 的对象赋了一个超出其范围的值，结果是该值对该类型可容纳值的总数**取模** (modulo) 后的余数。例如，一个 8 位的 `unsigned char`（范围 0-255）被赋予 -1，其结果将是 -1 对 256 取模，即 255。
- 如果我们给一个**有符号类型** (signed) 的对象赋了一个超出其范围的值，其结果是**未定义的** (undefined)。程序可能看起来能工作，也可能会崩溃，或者产生垃圾值。

#### 含有无符号类型的表达式

当一个算术表达式中既有**无符号数**又有**有符号数**时，有符号数会被转换为无符号数：

```cpp
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl; // 输出 -84
std::cout << i + u << std::endl; // 如果 int 占 32 位，输出 (10-42) % 2^32 = 4294867264
```

当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值：

```cpp
unsigned ul = 42, u2 = 10;
std::cout << ul - u2 << std::endl; //正确：检出32
std::cout << u2 - ul << std::endl; //正确：不过，结果是取模后的值，输出 (10-42) % 2^32 = 4294867264
```

🪤 陷阱：

```cpp
for (int i = 10; i >= 0; --i)
    std::cout << i << std::endl;
```

这段函数是为了从10到0降序输出，但如果将`i`设置为无符号数，那在`i==0`后，进行`--i`操作，`i`将被赋值为 $-1 \bmod 2^{32} = 2^{32} -1 = 4,294,967,295$。

#### 练习

##### 2.3 & 2.4 读程序写结果

```cpp
unsigned u = 10, u2 = 42;
std::cout << u2 - u << std::endl; // 1
std::cout << u - u2 << std::endl;// 2
int i = 10, i2 = 42;
std::cout << 12 -i << std::endl; // 3
std::cout << i - i2 << std::endl; // 4
std::cout << i - u << std::endl; // 5
std::cout << u - i << std::endl; // 6
```

预测答案：

- [x] 1. 32
- [x] 2. 4294867264
- [x] 3. 2
- [x] 4. -32
- [x] 5. 0
- [x] 6. 0

### 2.1.3 字面量常量

#### 整型和浮点型字面值

整型字面值可写作十进制数、八进制数或十六进制数的形式。以 `0` 开头的整数代表八进制数，以 `Ox` 或 `0X` 开头的代表十六进制数。

默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。

- 十进制字面值的类型是 int long 和 long long 中**尺寸最小**的那个；
- 类型 short 没有对应的字面值；
- 八进制和十六进制字面值的类型是能容纳其数值的 int、unsigned int、long、unsigned long、long long 和 unsigned long long 中**尺寸最小**的那个；
- 如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用 E 或 e 标识：

```plaintext
3.14159 3.14159EO 0. OeO .001
```

#### 字符和字符串字面值

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式：

```cpp
std::cout << "hello hello hello"
        "World!" << std::endl;
```

#### 转义序列

有两类字符程序员不能直接使用：一类是不可打印（ nonp ri ntable) 的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单引号、双引号、问号、反斜线）。

C++语言规定的转义序列包括：

|                |     |        |     |
| -------------- | --- | ------ | --- |
| 换行符         | \n  | 双引号 | \"  |
| 横向制表符     | \t  | 单引号 | \'  |
| 报警（响铃）符 | \a  | 反斜线 | \\  |
| 纵向制表符     | \v  | 问号   | \?  |
| 退格符         | \b  | 回车符 | \r  |
| 进纸符         | \f  |        |     |

我们也可以使用泛化的转义序列，其形式是＼x 后紧跟 1个或多个十六进制数字，或者＼后紧跟 1 个、2 个或3 个八进制数字，其中数字部分表示的是字符对应的数值。假设使用的是 Latin-1 字符集，以下是一些示例：

|              |               |               |
| ------------ | ------------- | ------------- |
| \7（响铃）   | \12（换行符） | \40（空格）   |
| \0（空字符） | \115（字符M） | \x4d（字符M） |

![指定字面值的类型](/images/20251028195503.png)

#### 布尔字面值和指针字面值

- 布尔字面值：true 和 false
- 指针字面值：nullptr

#### 练习

##### 2.5

![练习2.5](/images/20251028195658.png)

(a)

| 字面值 | 数据类型         | 描述                                                    |
| ------ | ---------------- | ------------------------------------------------------- |
| 'a'    | char             | 占一个字节                                              |
| L'a'   | wchar_t          | 长字符，占两个字节                                      |
| "a"    | const char[2]    | 占两个字节，第一个字节内容为'a'，第二个字节内容为'\0'   |
| L"a"   | const wchar_t[2] | 占四个字节，第一个字节内容为L'a'，第二个字节内容为L'\0' |

(b)

| 字面值 | 数据类型      | 描述                         |
| ------ | ------------- | ---------------------------- |
| 10     | int           |                              |
| 10u    | unsigned int  |                              |
| 10L    | long          |                              |
| 10uL   | unsigned long |                              |
| 012    | int           | 八进制数，表示为十进制的10   |
| 0xc    | int           | 十六进制数，表示为十进制的12 |

(c)

| 字面值 | 数据类型    | 描述           |
| ------ | ----------- | -------------- |
| 3.14   | double      | 双精度浮点数   |
| 3.14f  | float       | 单精度浮点数   |
| 3.14L  | long double | 长双精度浮点数 |

(d)

| 字面值 | 数据类型     | 描述               |
| ------ | ------------ | ------------------ |
| 10     | int          |                    |
| 10u    | unsigned int |                    |
| 10.    | double       | 浮点数，等价于10.0 |
| 10e-2  | double       | 科学计数法         |

##### 2.6

![练习2.6](/images/20251028195716.png)

有区别

1. 第一行是将十进制整型字面量赋值给`month`和`day`。
2. 第二行的字面量为八进制格式，但`month`赋值为`09`不对，会产生编译错误，应该赋值为`011`。

##### 2.7

![练习2.7](/images/20251028195731.png)

- (a) 字符串，用到了转义序列，具体值为 "Who goes with Fergus?"，最后的`\012`表示一个换行符
- (b) 科学计数法表示的 long double 类型，值为 31.4
- (c) float 类型，值为1024.0
- (d) long double 类型，值为3.14

##### 2.8

![练习2.8](/images/20251028195748.png)

```cpp
#include <iostream>

int main()
{
    std::cout << "2M" << std::endl;
    std::cout << 2 << '\t' << 'M' << std::endl;
    return EXIT_SUCCESS;
}
```

## 2.2 变量

### 2.2.1 变量定义

- 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值抹除，而以一个新值未替代。
- 初始化的四种方式：
  - int units_sold = 0;
  - int units_sold = {0}; // 列表初始化
  - int units_sold{0}; // 列表初始化
  - int units_sold(0);
  
  需注意的是，列表初始化在用于**内置类型**的变量时，如果初始值有丢失信息的风险，编译器会报错：
  - long double ld = 3.1415;
  - int a{ld}, b = {ld}; // 报错，向下取整导致的信息丢失
  - int c(ld), c = ld; // 不报错，虽然丢失信息，但没有使用列表初始化
- 默认初始化
  - 若一个内置类型的变量定义于任何函数体之外，它会被初始化为0；
  - 定义在函数内部的内置类型变量不会被初始化，一个未初始化的值是**未定义**的，如果试图拷贝或访问它将引发错误；
  - 类的对象如果没有显式地初始化，则其值由类确定。

#### 练习

##### 2.9

![题目2.9](/images/20251030151659.png)

- (a) **定义非法**，在 C++ 中，不能在输入流操作符 `>>` 的右侧同时进行变量声明和读取。输入操作符期望的是一个已存在的左值。
- (b) **定义非法**，使用列表初始化（list initialization）时，C++11 及以后的标准不允许窄化转换（narrowing conversion）。将 `double` 类型的 `3.14` 转换为 `int` 会丢失小数部分，属于窄化转换，因此编译器会报错。
- (c) **定义非法**，变量 `wage` 在使用前未声明。此语句试图将 `9999.99` 赋值给未定义的 `wage`，然后再将结果赋给 `salary`，应该修正为`double wage = 9999.99, salary = wage;`。
- (d) **定义正确**，这是传统的拷贝初始化（copy initialization），允许隐式类型转换。3.14 会被截断为 3，赋值给 i。这种写法在 C++ 中是合法的，但会导致精度丢失（编译器可能会给出警告）。

##### 2.10

![题目2.10](/images/20251030151716.png)

- `std::string global_str`: 空字符串，`std::string`是类类型，如果没有显式初始化，则其值由此类的无参构造函数决定。
- `int global_int`: 声明在所有函数体外，默认初始化为0。
- `int local_int`: 声明在函数体内，不进行初始化，值是未定义的(通常是内存中的随机值)。
- `std::string local_str`: 空字符串，`std::string`是类类型，如果没有显式初始化，则其值由此类的无参构造函数决定。

### 2.2.2 变量声明和定义的关系

如果想在多个文件中使用同一变量，就需要将变量声明和定义分开来：

- 在一个文件中定义变量
- 在用到该变量的文件中声明变量（不可重复定义该变量）

使用方法：

- 定义变量：`double pi = 3.14;`
- 声明变量：`extern double pi;`
- 用`extern`关键字声明的变量也可以加上`=`来定义它的值，但这就变成了定义变量而不是声明变量
- 若在**函数题内部**试图**初始化**一个由`extern`关键字标记的变量，将引发错误：
  
  ```plaintext
  test.cpp:8:16: error: declaration of block scope identifier with linkage cannot have an initializer
    8 |     extern int extern_i = 3;
      |                ^
    1 error generated.
  ```

#### 练习

##### 2.11

![题目2.11](/images/20251030154324.png)

- (a) **定义**：虽然使用了 extern 关键字,但因为同时进行了初始化(= 1024),这会抵消 extern 的作用。任何包含了显式初始化的声明都是定义,即使带有 extern。因此，这是一个定义，而不是单纯的声明。
- (b) **定义**：这是一个没有 extern 关键字的普通变量声明。对于全局作用域(假设这些语句在函数外部),这既是声明也是定义。变量 iy 会被分配存储空间并默认初始化为 0。
- (c) **声明**：使用了 extern 关键字且没有初始化。这是一个纯声明,表示变量 iz 在其他地方定义。这个语句只是告诉编译器 iz 的类型和存在性,但不为其分配存储空间。

### 2.2.3 标识符

- C++的标识符(identifier) 由**字母、数字和下画线**组成，且必须以**字母或下划线**开头。
- 用户自定义的标识符中不能**连续出现两个下划线**，也不能以**下划线紧连大写字母**开头。此外，定义在**函数体外的标识符**不能以下划线开头。

变量命名规范：

- 标识符要能体现实际含义。
- 变量名一般用小写字母，如 index, 不要使用 Index 或 INDEX。
- 用户自定义的类名一般以大写字母开头，如Sales_item。
- 如果标识符由多个单词组成，则单词间应有明显区分，如 student_loan 或studentLoan, 不要使用studentloan。

![表2.3 C++关键字](/images/20251030155138.png)
![表2.4 C++操作符替代名](/images/20251030155201.png)

#### 练习

##### 2.12

![练习2.12](/images/20251030155241.png)

- (a) 非法，标识符不能和关键字重名
- (b) 合法
- (c) 非法，标识符只能包含下划线、字母和数字，不能包含运算符
- (d) 非法，标识符必须以下划线或字母开头，不能以数字开头
- (e) 合法，标识符大小写敏感，Double不是关键字

### 2.2.4 作用域

以下例进行说明：

```cpp
#include <iostream>
// 该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量

int reused = 42; // reused 拥有全局作用域
int main(){
    int unique = 0; // unique 拥有块作用域
    std::cout < reused << " " << unique << std::endl; // 输出#1：使用全局变量 reused；输出 42 0
    int reused = 0; // 新建局部变量 reused，覆盖了全局变量 reused
    std::cout << reused << " " < unique << std::endl; // 输出#2：使用局部变量 reused；输出0
    std::cout << ::reused << " " < unique << std::endl; // 输出#3：显式地访问全局变量  reused；输出 42 0
    return 0;
}
```

作用域分为：全局作用域和块作用域。

- 全局作用域：定义在所有函数体之外的作用域；
- 块作用域：定义在花括号`{}`内的作用域。

也可按相对关系分为：

- 内层作用域
- 外层作用域

内层作用域能访问外层作用域定义的所有名字，也能重新定义外层作用域中存在的名字。

因为全局作用域本身并没有名字，所以当作用域操作符`::`的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。

#### 练习

##### 2.13

![练习 2.13](/images/20251030162021.png)

在 main 函数内部:

- 局部变量 int i = 100，定义在函数作用域内，**隐藏**了全局作用域的 `i = 42`
- 根据作用域规则，在内层作用域中，如果有同名变量，会优先使用内层的变量
- 因此 `int j = i;` 使用的是局部变量 `i`,其值为 `100`

##### 2.14

![练习 2.14](/images/20251030162029.png)

程序合法，但输出不是期望的结果，在`for`语句中定义的`i`在离开`for`语句定义的代码块后便失效，因此打印出来的是`100 45`。

## 2.3 复合类型

C++ 有几种复合类型，本章将介绍其中的两种：引用和指针。

更通用地说，一条声明语句由一个 **基本数据类型（base type）** 和紧随其后的一个 **声明符（declarator）** 列表组成。每个声明符命名了一个变量，并指定该变量为**与基本数据类型有关的某种类型**。

目前为止接触到的声明语句中,声明符就是变量名。其实还有更复杂的声明符,它基于基本数据类型得到更复杂的类型,并把它指定给变量。

### 2.3.1 引用

> 一般情况下说的引用都指"左值引用（lvalue reference）",C++ 11中新增了一种引用,名为"右值引用（rvalue reference）",这种引用主要用于内置类,将在13.6.1节做更详细的介绍。

引用相当于对象的别名，通过将声明符写成`&d`的形式来定义引用类型，其中`d`是声明的类型名：

```cpp
int ival = 1024;
int &refVal = ival; // refVal 指向 ival（是 ival 的别名）
int &refVal2; // 报错，引用必须被初始化
```

定义引用时，程序把引用和它的初始值**绑定**在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将无法重新绑定到另一个对象，因此**引用必须初始化**。

定义一个引用后，对其的操作等同于对其绑定对象的操作：

```cpp
int iVal = 0;
int &refVal = iVal;
refVal = 3;
std::cout << iVal << std::endl; // refVal 和 iVal 均为3
```

⚠️ 因为引用本身不是一个对象，所以不能定义引用的引用。

除 [2.4.1节](#_241-const-的引用) 和 15.1.3 节 介绍的两种例外情况，其他所有引用的类型都要和与之绑定的对象**严格匹配**：

```cpp
int &refVal = 10; // 错误：引用类型的初始值必须是一个对象，不能是字面值或某个表达式的计算结果
double dval = 3.14;
int &refVal2 = dval; // 错误：此处引用类型的初始值必须是 int 型对象
```

#### 练习

##### 2.15

下面的哪个定义是不合法的？为什么？

![练习 2.15](/images/20251030200935.png)

- (a) 合法；
- (b) 非法，除常量引用外，引用的初始值必须是一个对象，不能是字面值或某个表达式的计算结果；
- (c) 合法；
- (d) 不合法，引用必须初始化。

##### 2.16

![练习 2.16](/images/20251030201225.png)

- (a) 合法，为引用赋值实际上是把值赋给了与引用绑定的对象，在这里是把`3.14159`赋给了`d`；
- (b) 合法，这里实际是把`i`的值赋给了`d`；
- (c) 合法，这里实际是把`d`的值赋给了`i`，执行了窄化操作；
- (d) 合法，这里实际是把`d`的值赋给了`i`，执行了窄化操作。

### 2.3.2 指针

指针和引用一样，都实现了对其他对象的**间接访问**。但和引用不同的是：

1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且可以先后指向不同的对象；
2. 指针无须在定义时赋初值，在块作用域内定义的指针如果没有被初始化，将拥有一个不确定的值。

#### 获取对象的地址

指针存放某个**对象**的地址，要想获取该地址，需要使用**取地址符(&)**。因为引用不是对象，所以不能定义指向引用的指针。

```cpp
int ival = 42;
int *p = &ival;
```

除了 [2.4.2 节](#_242-指针和-const) 和15.2.3 节介绍的两种情况，所有指针的类型都要和它所指向的对象严格匹配。

```cpp
double dval;
double *pd = &dval; // 正确
double *pd2 = pd; // 正确

int *pi = pd; // 错误：指针 pi 的类型和 pd 的类型不匹配
pi = &dval; // 错误：试图把 double 型对象的地址赋给 int 型指针
```

#### 指针值

指针的值（即地址）应属于下列 4 种状态之一：

1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，意味着指针没有指向任何对象。
4. 无效指针，上述情况之外的其他值。

#### 利用指针访问对象

如果指针指向了一个对象，需使用 **解引用符(\*)** 来访问该对象。

```cpp
int ival = 42;
int *p = &ival;
cout << *p; // 输出 42
```

⚠️ 解引用操作仅适用于那些确实指向了某个对象的**有效指针**。

#### 空指针

空指针不指向任何对象，在试图使用一个指针之前可以首先检查它是否为空。生成空指针的方法有如下三种，它们是等价的：

```cpp
int *p1 = nullptr; // C++ 11 新标准引入的方法
int *p2 = 0;
// 需要先 #include <cstdlib>
int *p3 = NULL;
```

- `nullptr`可以被转换成任意其他的指针类型。
- `NULL` 是一个**预处理变量（preprocessor variable）**，预处理变量不属于命名空间`std`，它由**预处理器**负责管理，2.6.3节 将简单介绍预处理器相关知识。
- ⚠️ 把 int 变量直接赋给指针是错误的操作，即使该变量恰好等于0。
- ⚠️ 建议初始化所有的指针，并尽量等定义了对象之后再定义指向他的指针。
- ⚠️ 建议`C++ 11`后尽量使用`nullptr`而不是`NULL`来定义空指针，否则容易在函数重载时，`NULL` 可能被解释为 `int` 类型,导致调用错误的重载版本。

#### 赋值和指针

给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。

#### 其他指针操作

- 任何非 0 指针对应的条件值都是`true`
- 如果两个指针**存放的地址**相同，则它们相等；反之它们不相等
- ⚠️ 一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相等的情况，这种情况通常发生在**数组或连续分配的对象**中：

     ```cpp
    struct Object {
        int data;
    };

    Object obj1;  // 对象1
    Object obj2;  // 对象2

    Object* ptr1 = &obj2;           // ptr1指向obj2
    Object* ptr2 = &obj1 + 1;       // ptr2指向obj1的下一地址

    // 如果obj1和obj2在内存中恰好是连续存储的
    // 那么 ptr1 == ptr2 就可能成立
    ```

#### void* 指针

`void*`是一种特殊的指针类型，可用于存放**任意对象**的地址，但不能直接操作该类型指针所指的对象。

#### 练习

##### 2.18

编写代码分别更改指针的值以及指针所指对象的值。

```cpp
int main()
{
    int i = 5, j = 10;
    int *p = &i;
    cout << p << " " << *p << endl;
    p = &j;
    cout << p << " " << *p << endl;
    *p = 20;
    cout << p << " " << *p << endl;
    j = 30;
    cout << p << " " << *p << endl;
    return EXIT_SUCCESS;
}
```

输出结果：

```plaintext
0x16ddfa5c8 5
0x16ddfa5c4 10
0x16ddfa5c4 20
0x16ddfa5c4 30
```

##### 2.19

说明指针和引用的主要区别。

1. 引用必须初始化，指针可以不初始化；
2. 引用不是对象，指针是一个对象；
3. 引用不能改变其绑定对象，指针可以更改其指向的地址，从而改变指向的对象。

##### 2.20

请叙述下面这段代码的作用：

```cpp
int i = 42;
int *p1 = &i;
*p1 = *p1 * *p1;
```

`p1`指向`i`对象，代码实际作用是让`i = 42 * 42`。

##### 2.21

请解释下述定义。在这些定义中有非法的吗？如果有，为什么？

```cpp
int i = 0;
```

(a) double\* dp = \&i; (b)int \*ip = i; (c) int \*p = \&i;

- (a) 非法，`dp`应该指向`double`类型的对象而不是`int`类型的
- (b) 非法，等号左侧是`int*`类型，右侧是`int`类型，应该用`&`取地址符来获取`i`的地址
- (c) 合法

##### 2.22

假设 p 是一个 int 型指针，请说明下述代码的含义。

```cpp
if (p) // ...
if (*p) // ...
```

第一句判断`p`指针的值：

- 如果`p`指针指向一个真实存在的变量，则其值必不为0，此时条件为真；
- 如果`p`指针为无效指针，此时条件为真，对`p`的使用将引发不可预计的结果；
- 如果`p`为0，则条件为假。

第二句判断`p`指针指向的 int 对象的值：

- 如果该值为0，条件为假；如果值不为0，条件为真。

##### 2.23

给定指针p，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，也请说明原因。

如果在**所有指针都初始化**的前提下，可以通过判断指针是否为`0`或`nullptr`来判断指针是否合法。否则，可以将`if(p)`置于`try...catch...`代码块中，如果程序块顺利进行，则表示指针合法，反之不合法。

##### 2.24

在下面这段代码中为什么p合法而lp非法？

```cpp
int i = 42;
void *p = &i;
long *lp = &i;
```

- `void*`指针可以指向任何类型的对象，而`lp`是一个长整型指针，`i`是一个整型对象，类型不符

### 2.3.3 理解复合类型的声明

#### 定义多个变量

涉及指针或引用的声明，一般有两种写法。

1. 把修饰符和变量标识符写在一起，着重强调**变量具有的复合类型**：

    ```cpp
    int *p1, *p2;
    ```

2. 把修饰符和类型名写在一起，并且每条语句只定义一个变量，着重强调**本次声明定义了一种复合类型**：

    ```cpp
    int *p1;
    int *p2;
    ```

#### 指向指针的指针

指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针中。

通过\*的个数可以区分指针的级别。也就是说，\*\*表示指向指针的指针，\*\*\*表示指向指针的指针的指针，以此类推。

![多重指针示意图](/images/20251030230436.png)

#### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```cpp
int i = 42;
int *p;         // p 是一个 int 型的指针
int *&r = p;    // r 是与指针 p 绑定的引用

r = &i;         // r = &i 等同于 p = &i
*r = 0;         // *r = 0 等同于 *p = 0
```

要理解`r`的类型，最有效的方法是**从右向左**阅读`r`的定义：

1. `r`左侧是`&`，表示`r`是一个引用
2. `&r`左侧是`*`，表示`r`是一个对指针的引用
3. `*&r`左侧是`int`，表示`r`是一个对int类型指针的引用

#### 练习

##### 2.25

说明下列变量的类型和值。

![题目 2.25](/images/20251030235015.png)

- (a) ip为int类型指针，值不确定；i为int类型变量，如果定义在块作用域内，值不确定；r为i的引用，值为不确定。
- (b) i为int类型变量，如果定义在块作用域内，值不确定；ip为空指针，值为0.
- (c) ip为int类型指针，值不确定；ip2为int类型变量，如果定义在块作用域内，值为不确定。

## 2.4 const 限定符

默认情况下，const 对象被设定为**仅在文件内有效**，如果需要一个 const 变量，它的初始值不是一个常量表达式，但又需要在文件间共享，就需要：*对于 const 变量不管是声明还是定义都添加 extern 关键字*：

```cpp
// file_1.cc定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
// file_1.h头文件
extern const int bufSize; // 与 file_1.cc 中定义的 bufSize 是同一个
```

### 2.4.1 const 的引用

把引用绑定到`const`对象上,称为**对常量的引用（reference to const）**,对常量的引用不能修改它绑定的对象:

```cpp
const int ci = 1024;
const int &r1 = ci; // 正确：引用及其对应的对象都是常量

r1 = 42; // 错误：r1是对常量的引用
int &r2 = ci; // 错误：试图让一个非常量引用指向一个常量对象
```

引用的对象是常量还是非常量可以决定其所能参与的操作，但不会影响到引用和对象的绑定关系本身。

#### 初始化和对const的引用

[2.3.1 节](#_231-引用) 提到，引用的类型必须与其所引用对象的类型一致，但有两个例外，这是第一个例外：

初始化**常量引用**时，允许使用**任意表达式**作为初始值，只要该表达式的结果能转换成引用的类型即可（参见[2.1.2 节](#_212-类型转换)：

```cpp
int i = 42;
const int &r1 = i;      // 允许将 const int& 绑定到一个普通 int 对象上
const int &r2 = 42;     // 正确
const int &r3 = r1 * 2; // 正确
int &r4 = r1 * 2;       // 错误：r4是一个普通的非常量引用
```

现在具体解释一下为什么`int &r4 = r1 * 2` 这种写法是非法的：

当使用一个常量引用来引用一个类型不匹配的对象时，编译器会创建一个**临时对象**来完成绑定：

```cpp
double dval = 3.14;
const int &ri = dval;
```

编译器实际会将代码转换为：

```cpp
const int temp = dval; // 创建一个临时的int常量，值为3（截断）
const int &ri = temp; // ri引用这个临时量
```

如果允许非常量引用绑定到临时量，会出现问题：

```cpp
int &r4 = ri * 2;
```

假设这样可以，程序员可能想通过 r4 修改 ri * 2 的结果，但临时对象马上就销毁了，修改毫无意义。这种行为很容易导致错误，所以**C++禁止非常量引用绑定到临时对象**。

#### 对 const 的引用可能引用一个并非 const 的对象

如果被绑定的对象不是一个 const，那么定义的引用可以是 const 或不是 const，如果引用是 const，那就不能通过该引用来修改绑定的对象：

```cpp
int i = 42;
int &r1 = i;
const int &r2 = i;
r1 = 0; // 正确
r2 = 0; // 错误
```

### 2.4.2 指针和 const

常量指针**必须初始化**，初始化完成后，其值不能改变。

把`*`放在`const`关键字**之前**用以说明指针是一个厂里那个，这样的书写形式还有一层含义：不变的是指针本身的值而非指向的那个值：

```cpp
int errNumb = 0;
int *const curErr = &errNumb;
const double pi = 3.14159;
const double *const pip = &pi;
```

如何去理解两个常量指针声明的含义？**从右往左**读

- 离`curErr`最近的是`const`，表示这是一个常量对象，对象的类型由声明符的其余部分决定；
- 声明符中下一个符号是`*`，表示`curErr`是一个常量指针；
- 基本数据类型部分确定了常量指针指向饿是一个`int`对象。

指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于**所指对象的类型**。

#### 练习

##### 2.27

下面的哪些初始化是合法的？请说明原因。

![题目 2.27](/images/20251031180949.png)

- (a) 非法，只有常量引用才能用字面量初始化
- (b) 合法
- (c) 合法
- (d) 合法
- (e) 合法
- (f) 非法，常量指针必须初始化
- (g) 合法

##### 2.28

![练习 2.28](/images/20251031181352.png)

- (a) 非法，`cp`是常量指针，定义时必须初始化
- (b) 非法，`p2`是常量指针，定义时必须初始化
- (c) 非法，`ic`是一个常量，定义时必须初始化
- (d) 非法，`p3`作为常量指针，定义时必须初始化
- (e) 定义一个指向`const int`对象的指针`p`，但没有指向任何对象

##### 2.29

![练习 2.29](/images/20251031181422.png)

- (a) 合法，可以用常量来给非常量赋值
- (b) 非法，普通指针`p1`指向了一个常量，从语法上说，`p1`的值可以随意改变，显然是不合理的
- (c) 非法，普通指针`p1`指向了一个常量，错误情况与上一条类似
- (d) 非法，常量指针一旦初始化就不能改变值
- (e) 非法，常量指针一旦初始化就不能改变值
- (f) 非法，常量一旦初始化就不能改变值

### 2.4.3 顶层 const

> **指针本身是不是常量** 和 **指针所指的对象是不是常量** 是两个相互独立的问题。

用名词 **顶层 const（top-level const）** 表示指针本身是个常量，用名词 **底层 const（low-level const）** 表示指针所指对象是一个常量。

更一般地说：

- 对任何数据类型，顶层 const 可以表示**任意对象是常量**
- 底层 const 则与指针和引用等复合类型的**基本类型部分**有关
- 指针类型可以既是顶层 const 又是底层 const

一言蔽之，顶层const表示对象本身是常量，底层const表示不能通过该指针/引用修改其所指/绑定的对象。

更通俗的理解：

- 顶层const："我自己"不能变
- 底层const："我指向/绑定的东西"不能通过我来修改（但我可以指向/绑定别的东西）

```cpp
int i = 0;
int *const p1 = &i;             // 顶层`const`，p1是一个常量指针
const int ci = 42;              // 顶层`const`，ci是一个常量
const int *p2 = &ci;            // 底层`const`，p2是一个指向常量的非常量指针，自身可以改变，但无法通过其修改ci的值
const int *const p3 = p2;       // 靠右的是顶层`const`，靠左的是底层`const`，p3既不能改变指向的对象，也不能修改指向对象的值
const int &r = ci;              // 由于引用类型天然无法修改自己，所以天然具有顶层`const`的特性，因此用于声明引用的`const`都是底层`const`
```

在执行对象的**拷贝**操作时，常量是顶层const还是底层const区别明显，其中，顶层const不受什么影响：

```cpp
i = ci;                         // 正确，拷贝ci的值，ci是一个顶层`const`，无影响
p2 = p3;                        // 正确，p2 和 p3 指向的对象类型相同，且 p3 的顶层`const`部分不影响拷贝操作
```

但底层const限制较大：拷入和拷出的对象必须具有相同的底层const，或者两个对象的数据类型必须能够转换，一般来说，非常量可以转换成常量，反之则不行：

```cpp
int *p = p3;        // 错误：p3包含底层const的定义，p没有
p2 = p3;            // 正确：p2 和 p3 都是底层const
p2 = &i;            // 正确：int* 能转换为 const int*
int &r = ci;        // 错误：r包含底层const的定义，ci没有
const int &r2 = i;  // 正确
```

#### 练习

##### 2.30

![练习 2.30](/images/20251101123042.png)

- `v2`: 顶层 const
- `v1`: 非常量
- `p1`: 非常量
- `r1`: 默认包含顶层 const 的定义
- `p2`: 底层 const
- `p3`: 顶层和底层 const
- `r2`: 底层 const

##### 2.31

![练习 2.31](/images/20251101123059.png)

- `r1 = v2`: 非法，r1是引用类型，初始化后不能修改，这里体现了顶层const定义的变量自身值不能修改的特性。
- `p1 = p2`: 非法，p2指向的是`const int`，p1指向的是`int`，类型不能转换，体现了底层const的限制：两个对象的数据类型必须能够转换，一般来说，非常量可以转换成常量，反之则不行。
- `p2 = p1`: 合法，体现了底层const的限制：一般来说，非常量可以转换成常量，反之则不行。
- `p1 = p3`: 非法，p1是`int*`类型，p3是`const int *const`类型，两者不能转换，体现了底层const的限制：一般来说，非常量可以转换成常量，反之则不行。**将具有底层const的指针赋给非const指针是非法的。**
- `p2 = p3`: 合法，p2和p3都具有相同的底层const -> `const int*`，体现了底层const限制：拷入和拷出的对象必须具有相同的底层const。

### 2.4.4 constexpr 和 常量表达式

常量表达式（const expression）是指值不会改变并且在**编译过程**就能得到计算结果的表达式。

一个对象（或表达式）是不是常量表达式由它的**数据类型**和**初始值**共同决定：

```cpp
const int max_files = 20;           // max_files是常量表达式
cosnt int limit = max_files + 1;    // limit是常量表达式
int staff_size = 27;                // staff_size不是常量表达式
const int sz = get_size();          // sz不是常量表达式，因为它的具体值直到运行时才能获取到
```

#### constexpr 变量

- C++11 规定，允许将变量声明为 **constexpr** 类型，以便由**编译器**来验证变量的值是否是一个常量表达式。
- 声明为`constexpr`的变量一定是个常量，而且**必须用常量表达式初始化**：

```cpp
constexpr int mf = 20;          // 20 是常量表达式
constexpr int limit = mf + 1;   // mf + 1 是常量表达式
constexpr int sz = size();      // 只有当 size 是一个 constexpr 函数时，才是一条正确的声明语句
```

新标准允许定义一种特殊的 constexpr 函数，这种函数应该**足够简单以使得编译时就可以计算其结果**。

#### 字面值类型

声明 constexpr 时用到的类型必须是 **字面值类型**，字面值类型包括了：

- 算术类型、引用和指针
- 7.5.6节介绍的字面值类型
- 19.3节介绍的字面值类型

尽管指针和引用都能定义成 constexpr，一个 constexpr 指针的初始值**必须**是：

1. `nullptr`或`0`
2. 存储于某个**固定地址**中的对象

- **函数体内**的变量一般并非存放在固定地址中
- 定义于**所有函数体之外**的对象其地址**固定不变**，能用来初始化 constexpr 指针
- 6.1.1节 中将提到，允许函数定义一类有效范围超出函数本身的变量，也具有固定地址

#### 指针和constexpr

如果使用 constexpr 来定义指针，该限定符仅对指针有效，与指针所指的对象无关：

```cpp
const int *p = nullptr; // p是一个指向整型常量的指针
constexpr int *q = nullptr; // q是一个指向整数的常量指针
```

关键原因：`constexpr`将其定义的对象置为了**顶层 const**。

constexpr 指针既可以指向常量也可以指向一个非常量：

```cpp
constexpr int *np = nullptr;
int j = 0;
constexpr int i = 42;
constexpr const int *p = &i;    // p 是常量指针，指向整型常量 i
constexpr int *p1 = &j;         // p1 是常量指针，指向整数 j
```

#### 练习

##### 2.32

![练习 2.32](/images/20251101160138.png)

非法，`p`被定义为一个指向`int`对象的指针，应该通过**取地址符**&来取变量null的地址：

```cpp
int null = 0, *p = &null;
```

如果本意是定义一个值为0的整型变量，并设置p为空指针的话，应该这样写：

```cpp
#include <cstdlib>
int zero = 0, *p = NULL;
```

或者：

```cpp
int zero = 0, *p = nullptr;
```

## 2.5 处理类型

### 2.5.1 类型别名

有两种方法可用于定义类型别名：

1. 使用关键字`typedef`:

    ```cpp
    typedef double wages;   // wages 是 double 的同义词
    typedef wages base, *p; // base 是 double 的同义词，p 是 double* 的同义词
    ```

    `typedef`作为声明语句中的**基本数据类型的一部分**出现，含有`typedef`的声明语句定义的不再是变量而是类型别名。

2. C++ 11规定了一种新方法，使用别名声明（alias declaration）来定义类型别名：

    ```cpp
    using SI = Sales_item;  // SI 是 Sales_item 的同义词
    ```

#### 指针、常量和类型别名

<span style="color: red;">WARNING: 这小节需要重点强调！</span>

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是类型`char＊`的别名：

```cpp
typedef char *pstring;
const pstring cstr = 0; // cstr 是指向 char 的常量指针
const pstring *ps;      // ps 是一个指针，它指向的对象是指向 char 的常量指针
```

上述两条声明语句的基本数据类型都是`const pstring`，`const`是对给定类型的修饰。`pstring`实际上是指向`char`的指针，因此，`const pstring`就是指向`char`的常量指针，<span style="color: red;">而非指向常量字符的指针</span>。

遇到使用了类型别名的声明语句时，往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义：

```cpp
const char *cstr = 0;   // 是对 const pstring cstr 的错误理解
```

<span style="color: red;">再强调一遍，这种理解是错误的。</span>声明语句中用到`pstring`时，其基本数据类型是**指针**。如果用`char*`重写了声明语句后，基本数据类型就变成了`char`，`*`成为了声明符的一部分。这样改写的结果是，<span style="color: red;">const char成了基本数据类型</span>。

### 2.5.2 auto 类型说明符

- `auto` 让编译器通过初始值来推算变量的类型，显然，`auto` 定义的变量必须有初始值。

    ```cpp
    auto item = val1 + val2;    // item初始化为val1和val2想家的结果
    ```

    此处编译器将根据`val1`和`val2`**相加的结果**来推断`item`的类型。

- 使用`auto`也能在一条语句中声明多个变量，要求该语句中所有变量的**初始基本数据类型**都必须一样。

    ```cpp
    auto i = 0, *p = &i;    // 正确：i是整数、p是整型指针
    auto sz = 0, pi = 3.14; // 错误：sz和pi的类型不一致
    ```

#### 复合类型、常量和 auto

编译器推断出来的auto类型**有时候和初始值的类型并不完全一样**：

1. 当引用类型作为右值时，编译器以引用对象的类型作为`auto`的类型：

    ```cpp
    int i = 0, &r = i;
    auto a = r; // a 是一个整数（r 是 i 的别名，而 i 是一个整数）
    ```

2. `auto` 一般会**忽略顶层 const**，同时**底层 const**会保留下来：

    ```cpp
    const int ci = i, &cr = ci;
    auto b = ci;    // b 是一个整数（ci 的顶层 const 被忽略）
    auto c = cr;    // c 是一个整数（cr 是 ci 的别名，ci 的顶层 const 被忽略）
    auto d = &i;    // d 是一个整型指针（整数的地址就是指向整数的指针）
    auto e = &ci;   // e 是一个指向整型常量的指针（对常量取地址是一种底层 const）
    ```

3. 如果希望推断出的`auto`类型是一个**顶层 const**，需要显式指出：

    ```cpp
    const auto f = ci;
    ```

4. 可以将引用的类型设为`auto`，此时原来的初始化规则仍然适用：

    ```cpp
    // 当`auto`与引用结合时，`const`属性的处理方式与普通`auto`不同 —— 会保留`const`属性，因为引用必须尊重其所绑定对象的常量性。
    auto &g = ci;       // g 是一个整型常量引用，绑定到 ci，而不是整型引用
    auto &h = 42;       // 错误：不能为非常量引用绑定字面值
    const auto &j = 42; // 正确：可以为常量引用绑定字面追
    ```

5. 在一条语句中定义多个变量时，要谨记：<span style="color: red">符号 & 和 * 只从属于某个声明符，而非基本数据类型的一部分</span>。因此，初始值必须是同一种类型：

    ```cpp
    auto k = ci, &l = i;    // 正确
    auto &m = ci, *p = &ci; // 正确
    // auto 从 i 推导为 int，所以 n 是 int&
    // auto 从 &ci 应该推导为 const int，所以 p2 应该是 const int*
    // 但同一语句中 auto 不能同时是 int 和 const int，因此错误
    auto &n = i, *p2 = &ci;
    ```

#### 练习

##### 练习 2.33

利用本节定义的变星，判断下列语句的运行结果。

- `a = 42`: a 为 int 对象，赋值为 42
- `b = 42`: b 为 int 对象，赋值为 42
- `c = 42`: c 为 int 对象，赋值为 42
- `d = 42`: d 是一个整型指针，不能用整数来赋值
- `e = 42`: e 是一个指向整型常量的指针（`const int*`（指向 ci）），不能用整数来赋值
- `g = 42`: g 是一个整型常量引用（`const int&`（绑定到 ci）），不能通过常量引用修改所引用对象的值

##### 练习 2.34

基于上一个练习中的变量和语旬编写一段程序，输出赋值前后变量的内容，你刚才的推断正确吗？如果不对，请反复研读本节的示例直到你明白错在何处为止。

程序：

```cpp
#include <iostream>

using namespace std;

int main()
{
    int i = 0, &r = i;
    auto a = r;

    const int ci = i, &cr = ci;
    auto b = ci;
    auto c = cr;
    auto d = &i;
    auto e = &ci;

    const auto f = ci;

    auto &g = ci;
    auto &h = 42;
    const auto &j = 42;

    auto k = ci, &l = i;
    auto &m = ci, *p = &ci;
    auto &n = i, *p = &ci;

    a = 42;
    b = 42;
    c = 42;
    d = 42;
    e = 42;
    g = 42;

    return EXIT_SUCCESS;
}
```

编译结果：

![练习 2.34编译结果](/images/20251101234934.png)

从编译结果能看出，`d`和`e`赋值为42时，都是类型转换错误，而`g`赋值为42时，提示不能给`g`这个类型为`const int &`的引用赋值。

##### 练习 2.35

![练习 2.35](/images/20251101235154.png)

推断：

- `j`: int
- `k`: const int&
- `p`: int*
- `j2`: const int
- `k2`: const int&

程序验证：

```cpp
#include <iostream>
#include <typeinfo>

int main() {
    const int i = 42;
    auto j = i;
    const auto &k = i;
    auto *p = &i;
    const auto j2 = i, &k2 = i;
    
    // 类型验证
    std::cout << "j 的类型: " << typeid(j).name() << std::endl;
    std::cout << "k 的类型: " << typeid(k).name() << std::endl;
    std::cout << "p 的类型: " << typeid(p).name() << std::endl;
    std::cout << "j2 的类型: " << typeid(j2).name() << std::endl;
    std::cout << "k2 的类型: " << typeid(k2).name() << std::endl;
    
    // 赋值测试
    j = 50;      // 正确：j 是非常量 int
    // k = 50;   // 错误：k 是常量引用，不能修改
    // *p = 50;  // 错误：p 指向常量，不能通过 p 修改
    // j2 = 50;  // 错误：j2 是常量
    // k2 = 50;  // 错误：k2 是常量引用
    
    std::cout << "\n赋值测试通过，j 现在的值为: " << j << std::endl;
    
    return EXIT_SUCCESS;
}
```

测试：

```bash
./prog
j 的类型: i
k 的类型: i
p 的类型: PKi
j2 的类型: i
k2 的类型: i

赋值测试通过，j 现在的值为: 50
```

### 2.5.3 decltype 类型指示符

如果要 *从表达式的类型推断出要定义的变量的类型*，但不想用该表达式的值初始化变量，C++ 11中引入了关键字`decltype`，它的作用是**选择并返回操作数的数据类型**。

1. 如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（**包括顶层const和引用**），这点注意和auto区分开

    ```cpp
    const int ci = 0, &ci = ci;
    decltype(ci) x = 0; // x的类型是 const int
    decltype(cj) y = x; // y的类型是 const int&
    decltype(cj) z;     // 错误：z是一个引用，必须初始化
    ```

    - 引用从来都作为其所指对象的同义词出现，只有用在 decltype 处是一个**例外**

2. 如果decltype使用的表达式不是一个变量，则它返回**表达式结果对应的类型**，如 4.1.1节 介绍的，有些表达式将向 decltype 返回一个**引用类型**。一般这种情况发生时，意味着**该表达式的结果对象**能作为一条赋值语句的**左值**：

    ```cpp
    int i = 42, &p = &i, &r = i;
    decltype(r + 0) b;  // 正确，加法的结果是int，因此b是一个（未初始化的）int
    decltype(*p) c;     // 错误：如果表达式的内容是解引用操作，则decltype将得到引用类型，c是int&，必须初始化
    ```

    因为`r`是一个引用，因此`decltype(r)`的结果是引用类型，如果想让结果类型是`r`所指的类型，可以把它作为表达式的一部分，如`r+0`。

3. decltype的结果类型与表达式形式密切相关，对于 decltype 所用的表达式来说，如果变量名加上了**一对括号**，则得到的类型与不加括号时会有不同。

    - 如果 decltype 使用的是一个不加括号的变量，则得到的结果就是该变量的类型：

    ```cpp
    decltype(i) d;      // 正确：d 是一个（未初始化的）int
    ```

    - 如果 decltype 使用的是一个加上了一层或多层括号的变量，编译器就会把它当成是一个表达式：

    ```cpp
    decltype((i)) d;    // 错误：d 是一个 int&，必须初始化
    ```

4. 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型，也就是说，如果 i 是 int，则表达式 i=x 的类型是 int&，例子见[练习2.37](#_237)

#### 练习

##### 2.36

![练习 2.36](/images/20251102172744.png)

`a`, `b`, `c` 都是`int`型对象，`d`是`int&`型对象。

结束时，`a=4`, `b=4`, `c=4`, `d=4`。

##### 2.37

![练习 2.37](/images/20251102172951.png)

`a`, `b`, `c` 都是`int`型对象，`d`是整型引用。

表达式`a=b`作为`decltype`的参数，编译器分析表达式并得到它的类型作为`d`的推断类型，**但不实际计算该表达式**，所以`a`的值不发生改变，`d`是`a`的别名，最后，`a=3`, `b=4`, `c=3`, `d=3`。

##### 2.38

![练习 2.38](/images/20251102173621.png)

1. `auto`类型说明符用编译器计算变量的初始值来推断其类型，而`decltype`虽然也让编译器分析表达式并得到它的类型，但不实际计算表达式的值；
2. 编译器推断出来的`auto`类型有时候和初始值并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如，`auto`一般会忽略顶层const，保留底层const。相反，`decltype`会保留变量的顶层const；
3. 与`auto`不同，`decltype`的结果类型与表达式形式密切相关，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果`decltype`使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用类型。

示例程序：

```cpp
#include <iostream>
#include <typeinfo>

int main()
{
    int a = 3;

    auto c1 = a;          // c1 是 int
    decltype(a) c2 = a;   // c2 是 int
    decltype((a)) c3 = a; // c3 是 int&

    const int b = 2;
    auto d1 = b;          // d1 是 int
    decltype(b) d2 = b;   // d2 是 const int
    decltype((b)) d3 = b; // d3 是 const int&

    std::cout << typeid(c1).name() << std::endl;
    std::cout << typeid(c2).name() << std::endl;
    std::cout << typeid(c3).name() << std::endl;
    std::cout << typeid(d1).name() << std::endl;
    std::cout << typeid(d2).name() << std::endl;
    std::cout << typeid(d3).name() << std::endl;

    c1++;
    c2++;
    c3++;

    d1++;
    // d2++; 错误，d2 是一个常量
    // d3++; 错误，d3 是一个常量引用

    return EXIT_SUCCESS;
}
```

## 2.6 自定义数据结构

### 2.6.1 定义 Sales_data 类型

介绍了用`struct`定义`Sales_data`，详见`P64~P65`

### 2.6.2 使用 Sales_data 类

介绍了手动编码操作`Sales_data`结构体，详见`P66~P67`

### 2.6.3 编写自己的头文件

⚠️ 头文件一旦改变，相关的源文件必须**重新编译**以获取更新过的声明

#### 预处理器概述

- 预处理器是在**编译之前**执行的一段程序
- 预处理功能
  - `#include`: 当处理器看到`#include`标记时就会用指定的头文件的内容代替`#include`
  - 头文件保护符：依赖于预处理变量，预处理变量有两种状态：已定义和未定义。
    - `#define`: 把一个名字设定为预处理变量
    - `#ifdef`: 当且仅当变量已定义时为真
    - `#ifndef`: 当且仅当变量未定义时为真
    - 一旦检查结果为真，则执行后续操作直至遇到`#endif`指令为止
  - ⚠️ 预处理变量无视C++语言关于作用域的规则
  - ⚠️ 整个程序中的预处理变量包括头文件保护符必须**唯一**
  - ⚠️ 一般把预处理变量的名字全部大写
  - 程序员只需要习惯性地加上头文件保护符即可，不需要考虑程序到底需不需要
