---
date: 2025-10-27
title: 2. 变量和基本类型
description: 介绍了 C++ 的内置类型，了解 C++ 复杂数据类型
---

## 2.1 基本内置类型

### 2.1.1 算术类型

算术类型分为两类：整型和浮点型。

算术类型的尺寸在不同机器上有所差别。下表列出了 C++ 标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。

| Type | Meaning | Minimum Size |
|------|---------|--------------|
| bool | Boolean | N/A |
| char | Character | 8 bits |
| wchar_t | Wide character | 16 bits |
| char16_t | Unicode character | 16 bits |
| char32_t | Unicode character | 32 bits |
| short | Short integer | 16 bits |
| int | Integer | 16 bits |
| long | Long integer | 32 bits |
| long long | Long integer | 64 bits |
| float | Single-precision floating-point | 6 significant digits |
| double | Double-precision floating-point | 10 significant digits |
| long double | Extended-precision floating-point | 10 significant digits |

#### 字符类型

- 字符类型有多种，其中大多数是为了支持国际化而存在的。基本字符类型是 `char`。`char` 的大小保证足以容纳与机器基本字符集中的字符对应的数值。也就是说，`char` 的大小与**单个机器字节**相同。
- 其余字符类型——`wchar_t`、`char16_t` 和 `char32_t` ——用于扩展字符集。`wchar_t` 类型保证足够大，可以容纳机器最大扩展字符集中的任何字符。`char16_t` 和 `char32_t` 类型用于 `Unicode 字符`。

#### 其他整型

其余的整数类型表示（可能）不同大小的整数值。C++ 语言保证：

- int 至少与 short 大小相同
- long 至少与 int 大小相同
- long long 至少与 long 大小相同
- long long 类型是 C++ 11 标准引入的

#### 浮点类型

浮点类型表示单精度、双精度和扩展精度值。C++ 标准规定了有效数字的最小位数。大多数编译器提供的精度高于规定的最小值。通常：

- 浮点数（float）用一个字（32 位）表示
- 双精度数（double）用两个字（64 位）表示
- 长双精度数（long double）用三个或四个字（96 位或 128 位）表示

浮点数和双精度数通常分别产生约 7 位和 16 位有效数字。长双精度数通常用于兼容专用浮点硬件；其精度在不同实现之间可能存在差异。

#### 带符号类型和无符号类型

除去布尔型和扩展的字符型之外，其他整型可以划分为**带符号的（signed）** 和 **无符号的（unsigned）**。

与其他整型不同，字符型被划分为了三种：char、signed char 和 unsigned char。尽管字符型有三种，但字符的表现形式只有两种：带符号的和无符号的。类型 char 实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。

#### 建议：如何选择类型

- 当明确知晓数值不可能为负时，选用无符号类型；
- 使用int执行整数运算。如果数值超过了int的表示范围，选用long long；
- 在**算术表达式**中不要使用char或bool，如果需要一个不大的整数，要明确指定它的类型是signed char/unsigned char；
- 执行浮点运算用double，float和double的计算代价相差无几，对某些机器来说，double运算速度比float还快。

#### 练习

##### 2.1 类型int、long、long long和 short 的区别是什么？无符号类型和带符号类型的区别是什么？float 和 double 的区别是什么？

*我的回答*

1. int 至少与 short 大小相同；long 至少与 int 大小相同；long long 至少与 long 大小相同
2. 无符号类型大于等于0，带符号类型可小于、等于和大于0
3. float用一个字表示，double用两个字表示；float有效数位为7，double有效数位为17

*Claude修正后的回答*

1. int、long、long long 和 short 的区别

    **C++标准保证的最小尺寸要求：**

    - `short` 至少16位（2字节）
    - `int` 至少16位（2字节）
    - `long` 至少32位（4字节）
    - `long long` 至少64位（8字节）（C++11引入）

    **尺寸关系保证：**

    ```plaintext
    short ≤ int ≤ long ≤ long long
    ```

    **常见实现（取决于平台）：**

    - 32位系统：`short`(2字节)，`int`(4字节)，`long`(4字节)，`long long`(8字节)
    - 64位系统：`short`(2字节)，`int`(4字节)，`long`(4或8字节)，`long long`(8字节)

2. 无符号类型和带符号类型的区别

   - **带符号类型（signed）**：可以表示负数、零和正数，最高位为符号位
   - **无符号类型（unsigned）**：只能表示零和正数（≥0），所有位都用于表示数值

   **关键区别：**

   - 相同字节数下，无符号类型能表示的最大正数约为带符号类型的两倍
   - 例如：`unsigned int`(0 到 4,294,967,295) vs `int`(-2,147,483,648 到 2,147,483,647)

3. float 和 double 的区别

    | 特性 | float | double |
    |------|-------|--------|
    | **存储大小** | 4字节（32位） | 8字节（64位） |
    | **有效数字位数** | 约6-7位十进制数字 | 约15-16位十进制数字 |
    | **精度** | 单精度 | 双精度 |
    | **指数范围** | 约10^(-38)到10^(38) | 约10^(-308)到10^(308) |

    **术语说明：**

    - "字（word）"是一个与处理器架构相关的概念，在不同系统上大小不同
    - 更准确的表述应使用"字节（byte）"作为单位

    **建议：**

    - 一般情况下优先使用`double`，因为精度更高且现代处理器对double的运算效率与float相当
    - 只在内存受限或需要大量浮点数存储时考虑使用`float`

##### 2.2 计算按揭贷款时，对千利率、本金和付款分别应选择何种数据类型？说明你的理由

1. 利率：double

    - 利率为小数（如0.0525或5.25%）
    - 需要较高精度避免复利计算中的累积误差

2. 本金：double

    - 金额可能有小数（精确到分）
    - 数值范围在double表示范围内
    - 需要与利率进行浮点运算

3. 付款：double

    - 月供金额通常有小数
    - 由本金和利率计算得出，保持类型一致避免转换
    - 便于后续财务计算

### 2.1.2 类型转换

#### 转换准则

- 当我们将一个**非布尔值**的算术类型赋给一个 `bool` 对象时，如果原值是 0，则结果为 `false`，否则为 `true`。
- 当我们将一个 `bool` 值赋给一个**非 `bool` 值**的算术类型时，如果 `bool` 值为 `true`，则结果为 1，如果为 `false`，则结果为 0。
- 当我们将一个**浮点型**值赋给一个**整型**对象时，该值会被**截断** (truncated)。存储的值是小数点前的部分。
- 当我们将一个**整型**值赋给一个**浮点型**对象时，小数部分为零。如果该整数的位数（比特）超过了浮点型对象所能容纳的范围，可能会**损失精度**。
- 如果我们给一个**无符号类型** (unsigned) 的对象赋了一个超出其范围的值，结果是该值对该类型可容纳值的总数**取模** (modulo) 后的余数。例如，一个 8 位的 `unsigned char`（范围 0-255）被赋予 -1，其结果将是 -1 对 256 取模，即 255。
- 如果我们给一个**有符号类型** (signed) 的对象赋了一个超出其范围的值，其结果是**未定义的** (undefined)。程序可能看起来能工作，也可能会崩溃，或者产生垃圾值。

#### 含有无符号类型的表达式

当一个算术表达式中既有**无符号数**又有**有符号数**时，有符号数会被转换为无符号数：

```cpp
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl; // 输出 -84
std::cout << i + u << std::endl; // 如果 int 占 32 位，输出 (10-42) % 2^32 = 4294867264
```

当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值：

```cpp
unsigned ul = 42, u2 = 10;
std::cout << ul - u2 << std::endl; //正确：检出32
std::cout << u2 - ul << std::endl; //正确：不过，结果是取模后的值，输出 (10-42) % 2^32 = 4294867264
```

🪤 陷阱：

```cpp
for (int i = 10; i >= 0; --i)
    std::cout << i << std::endl;
```

这段函数是为了从10到0降序输出，但如果将`i`设置为无符号数，那在`i==0`后，进行`--i`操作，`i`将被赋值为 $-1 \bmod 2^{32} = 2^{32} -1 = 4,294,967,295$。

#### 练习

##### 2.3 & 2.4 读程序写结果

```cpp
unsigned u = 10, u2 = 42;
std::cout << u2 - u << std::endl; // 1
std::cout << u - u2 << std::endl;// 2
int i = 10, i2 = 42;
std::cout << 12 -i << std::endl; // 3
std::cout << i - i2 << std::endl; // 4
std::cout << i - u << std::endl; // 5
std::cout << u - i << std::endl; // 6
```

预测答案：

- [x] 1. 32
- [x] 2. 4294867264
- [x] 3. 2
- [x] 4. -32
- [x] 5. 0
- [x] 6. 0

### 2.1.3 字面量常量

#### 整型和浮点型字面值

整型字面值可写作十进制数、八进制数或十六进制数的形式。以 `0` 开头的整数代表八进制数，以 `Ox` 或 `0X` 开头的代表十六进制数。

默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。

- 十进制字面值的类型是 int long 和 long long 中**尺寸最小**的那个；
- 类型 short 没有对应的字面值；
- 八进制和十六进制字面值的类型是能容纳其数值的 int、unsigned int、long、unsigned long、long long 和 unsigned long long 中**尺寸最小**的那个；
- 如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用 E 或 e 标识：

```plaintext
3.14159 3.14159EO 0. OeO .001
```

#### 字符和字符串字面值

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式：

```cpp
std::cout << "hello hello hello"
        "World!" << std::endl;
```

#### 转义序列

有两类字符程序员不能直接使用：一类是不可打印（ nonp ri ntable) 的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单引号、双引号、问号、反斜线）。

C++语言规定的转义序列包括：

|  |  |   |   |
| ---- | ---- | ---- | ---- |
| 换行符 | \n | 双引号 | \" |
| 横向制表符 | \t | 单引号 | \' |
| 报警（响铃）符 | \a | 反斜线 | \\ |
| 纵向制表符 | \v | 问号 | \? |
| 退格符 | \b | 回车符 | \r |
| 进纸符 | \f | | |

我们也可以使用泛化的转义序列，其形式是＼x 后紧跟 1个或多个十六进制数字，或者＼后紧跟 1 个、2 个或3 个八进制数字，其中数字部分表示的是字符对应的数值。假设使用的是 Latin-1 字符集，以下是一些示例：

|    |    |    |
| -- | -- | -- |
|\7（响铃）|\12（换行符）|\40（空格）|
|\0（空字符）|\115（字符M）|\x4d（字符M）|

![指定字面值的类型](/images/20251028195503.png)

#### 布尔字面值和指针字面值

- 布尔字面值：true 和 false
- 指针字面值：nullptr

#### 练习

##### 2.5

![练习2.5](/images/20251028195658.png)

(a)

|字面值|数据类型|描述|
|-|-|-|
|'a'|char|占一个字节|
|L'a'|wchar_t|长字符，占两个字节|
|"a"|const char[2]|占两个字节，第一个字节内容为'a'，第二个字节内容为'\0'|
|L"a"|const wchar_t[2]|占四个字节，第一个字节内容为L'a'，第二个字节内容为L'\0'|

(b)

|字面值|数据类型|描述|
|-|-|-|
|10|int||
|10u|unsigned int||
|10L|long||
|10uL|unsigned long||
|012|int|八进制数，表示为十进制的10|
|0xc|int|十六进制数，表示为十进制的12 |

(c)

|字面值|数据类型|描述|
|-|-|-|
|3.14|double|双精度浮点数|
|3.14f|float|单精度浮点数|
|3.14L|long double|长双精度浮点数|

(d)

|字面值|数据类型|描述|
|-|-|-|
|10|int||
|10u|unsigned int||
|10.|double|浮点数，等价于10.0|
|10e-2|double|科学计数法|

##### 2.6

![练习2.6](/images/20251028195716.png)

有区别

1. 第一行是将十进制整型字面量赋值给`month`和`day`。
2. 第二行的字面量为八进制格式，但`month`赋值为`09`不对，会产生编译错误，应该赋值为`011`。

##### 2.7

![练习2.7](/images/20251028195731.png)

- (a) 字符串，用到了转义序列，具体值为 "Who goes with Fergus?"，最后的`\012`表示一个换行符
- (b) 科学计数法表示的 long double 类型，值为 31.4
- (c) float 类型，值为1024.0
- (d) long double 类型，值为3.14

##### 2.8

![练习2.8](/images/20251028195748.png)

```cpp
#include <iostream>

int main()
{
    std::cout << "2M" << std::endl;
    std::cout << 2 << '\t' << 'M' << std::endl;
    return EXIT_SUCCESS;
}
```

## 2.2 变量

### 2.2.1 变量定义

- 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值抹除，而以一个新值未替代。
- 初始化的四种方式：
  - int units_sold = 0;
  - int units_sold = {0}; // 列表初始化
  - int units_sold{0}; // 列表初始化
  - int units_sold(0);
  
  需注意的是，列表初始化在用于**内置类型**的变量时，如果初始值有丢失信息的风险，编译器会报错：
  - long double ld = 3.1415;
  - int a{ld}, b = {ld}; // 报错，向下取整导致的信息丢失
  - int c(ld), c = ld; // 不报错，虽然丢失信息，但没有使用列表初始化
- 默认初始化
  - 若一个内置类型的变量定义于任何函数体之外，它会被初始化为0；
  - 定义在函数内部的内置类型变量不会被初始化，一个未初始化的值是**未定义**的，如果试图拷贝或访问它将引发错误；
  - 类的对象如果没有显式地初始化，则其值由类确定。

#### 练习

##### 2.9

![题目2.9](/images/20251030151659.png)

- (a) **定义非法**，在 C++ 中，不能在输入流操作符 `>>` 的右侧同时进行变量声明和读取。输入操作符期望的是一个已存在的左值。
- (b) **定义非法**，使用列表初始化（list initialization）时，C++11 及以后的标准不允许窄化转换（narrowing conversion）。将 `double` 类型的 `3.14` 转换为 `int` 会丢失小数部分，属于窄化转换，因此编译器会报错。
- (c) **定义非法**，变量 `wage` 在使用前未声明。此语句试图将 `9999.99` 赋值给未定义的 `wage`，然后再将结果赋给 `salary`，应该修正为`double wage = 9999.99, salary = wage;`。
- (d) **定义正确**，这是传统的拷贝初始化（copy initialization），允许隐式类型转换。3.14 会被截断为 3，赋值给 i。这种写法在 C++ 中是合法的，但会导致精度丢失（编译器可能会给出警告）。

##### 2.10

![题目2.10](/images/20251030151716.png)

- `std::string global_str`: 空字符串，`std::string`是类类型，如果没有显式初始化，则其值由此类的无参构造函数决定。
- `int global_int`: 声明在所有函数体外，默认初始化为0。
- `int local_int`: 声明在函数体内，不进行初始化，值是未定义的(通常是内存中的随机值)。
- `std::string local_str`: 空字符串，`std::string`是类类型，如果没有显式初始化，则其值由此类的无参构造函数决定。

### 2.2.2 变量声明和定义的关系

如果想在多个文件中使用同一变量，就需要将变量声明和定义分开来：

- 在一个文件中定义变量
- 在用到该变量的文件中声明变量（不可重复定义该变量）

使用方法：

- 定义变量：`double pi = 3.14;`
- 声明变量：`extern double pi;`
- 用`extern`关键字声明的变量也可以加上`=`来定义它的值，但这就变成了定义变量而不是声明变量
- 若在**函数题内部**试图**初始化**一个由`extern`关键字标记的变量，将引发错误：
  
  ```plaintext
  test.cpp:8:16: error: declaration of block scope identifier with linkage cannot have an initializer
    8 |     extern int extern_i = 3;
      |                ^
    1 error generated.
  ```

#### 练习

##### 2.11

![题目2.11](/images/20251030154324.png)

- (a) **定义**：虽然使用了 extern 关键字,但因为同时进行了初始化(= 1024),这会抵消 extern 的作用。任何包含了显式初始化的声明都是定义,即使带有 extern。因此，这是一个定义，而不是单纯的声明。
- (b) **定义**：这是一个没有 extern 关键字的普通变量声明。对于全局作用域(假设这些语句在函数外部),这既是声明也是定义。变量 iy 会被分配存储空间并默认初始化为 0。
- (c) **声明**：使用了 extern 关键字且没有初始化。这是一个纯声明,表示变量 iz 在其他地方定义。这个语句只是告诉编译器 iz 的类型和存在性,但不为其分配存储空间。

### 2.2.3 标识符

- C++的标识符(identifier) 由**字母、数字和下画线**组成，且必须以**字母或下划线**开头。
- 用户自定义的标识符中不能**连续出现两个下划线**，也不能以**下划线紧连大写字母**开头。此外，定义在**函数体外的标识符**不能以下划线开头。

变量命名规范：

- 标识符要能体现实际含义。
- 变量名一般用小写字母，如 index, 不要使用 Index 或 INDEX。
- 用户自定义的类名一般以大写字母开头，如Sales_item。
- 如果标识符由多个单词组成，则单词间应有明显区分，如 student_loan 或studentLoan, 不要使用studentloan。

![表2.3 C++关键字](/images/20251030155138.png)
![表2.4 C++操作符替代名](/images/20251030155201.png)

#### 练习

##### 2.12

![练习2.12](/images/20251030155241.png)

- (a) 非法，标识符不能和关键字重名
- (b) 合法
- (c) 非法，标识符只能包含下划线、字母和数字，不能包含运算符
- (d) 非法，标识符必须以下划线或字母开头，不能以数字开头
- (e) 合法，标识符大小写敏感，Double不是关键字

### 2.2.4 作用域

以下例进行说明：

```cpp
#include <iostream>
// 该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量

int reused = 42; // reused 拥有全局作用域
int main(){
    int unique = 0; // unique 拥有块作用域
    std::cout < reused << " " << unique << std::endl; // 输出#1：使用全局变量 reused；输出 42 0
    int reused = 0; // 新建局部变量 reused，覆盖了全局变量 reused
    std::cout << reused << " " < unique << std::endl; // 输出#2：使用局部变量 reused；输出0
    std::cout << ::reused << " " < unique << std::endl; // 输出#3：显式地访问全局变量  reused；输出 42 0
    return 0;
}
```

作用域分为：全局作用域和块作用域。

- 全局作用域：定义在所有函数体之外的作用域；
- 块作用域：定义在花括号`{}`内的作用域。

也可按相对关系分为：

- 内层作用域
- 外层作用域

内层作用域能访问外层作用域定义的所有名字，也能重新定义外层作用域中存在的名字。

因为全局作用域本身并没有名字，所以当作用域操作符`::`的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。

#### 练习

##### 2.13

![练习 2.13](/images/20251030162021.png)

在 main 函数内部:

- 局部变量 int i = 100，定义在函数作用域内，**隐藏**了全局作用域的 `i = 42`
- 根据作用域规则，在内层作用域中，如果有同名变量，会优先使用内层的变量
- 因此 `int j = i;` 使用的是局部变量 `i`,其值为 `100`

##### 2.14

![练习 2.14](/images/20251030162029.png)

程序合法，但输出不是期望的结果，在`for`语句中定义的`i`在离开`for`语句定义的代码块后便失效，因此打印出来的是`100 45`。

## 2.3 复合类型

C++ 有几种复合类型，本章将介绍其中的两种：引用和指针。

更通用地说，一条声明语句由一个 **基本数据类型（base type）** 和紧随其后的一个 **声明符（declarator）** 列表组成。每个声明符命名了一个变量，并指定该变量为**与基本数据类型有关的某种类型**。

目前为止接触到的声明语句中,声明符就是变量名。其实还有更复杂的声明符,它基于基本数据类型得到更复杂的类型,并把它指定给变量。

### 2.3.1 引用

> 一般情况下说的引用都指"左值引用（lvalue reference）",C++ 11中新增了一种引用,名为"右值引用（rvalue reference）",这种引用主要用于内置类,将在13.6.1节做更详细的介绍。

引用相当于对象的别名，通过将声明符写成`&d`的形式来定义引用类型，其中`d`是声明的类型名：

```cpp
int ival = 1024;
int &refVal = ival; // refVal 指向 ival（是 ival 的别名）
int &refVal2; // 报错，引用必须被初始化
```

定义引用时，程序把引用和它的初始值**绑定**在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将无法重新绑定到另一个对象，因此**引用必须初始化**。

定义一个引用后，对其的操作等同于对其绑定对象的操作：

```cpp
int iVal = 0;
int &refVal = iVal;
refVal = 3;
std::cout << iVal << std::endl; // refVal 和 iVal 均为3
```

⚠️ 因为引用本身不是一个对象，所以不能定义引用的引用。

除 [2.4.1节](#_241-const-的引用) 和 15.1.3 节 介绍的两种例外情况，其他所有引用的类型都要和与之绑定的对象**严格匹配**：

```cpp
int &refVal = 10; // 错误：引用类型的初始值必须是一个对象，不能是字面值或某个表达式的计算结果
double dval = 3.14;
int &refVal2 = dval; // 错误：此处引用类型的初始值必须是 int 型对象
```

#### 练习

##### 2.15

下面的哪个定义是不合法的？为什么？

![练习 2.15](/images/20251030200935.png)

- (a) 合法；
- (b) 非法，除常量引用外，引用的初始值必须是一个对象，不能是字面值或某个表达式的计算结果；
- (c) 合法；
- (d) 不合法，引用必须初始化。

##### 2.16

![练习 2.16](/images/20251030201225.png)

- (a) 合法，为引用赋值实际上是把值赋给了与引用绑定的对象，在这里是把`3.14159`赋给了`d`；
- (b) 合法，这里实际是把`i`的值赋给了`d`；
- (c) 合法，这里实际是把`d`的值赋给了`i`，执行了窄化操作；
- (d) 合法，这里实际是把`d`的值赋给了`i`，执行了窄化操作。

### 2.3.2 指针

指针和引用一样，都实现了对其他对象的**间接访问**。但和引用不同的是：

1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且可以先后指向不同的对象；
2. 指针无须在定义时赋初值，在块作用域内定义的指针如果没有被初始化，将拥有一个不确定的值。

#### 获取对象的地址

指针存放某个**对象**的地址，要想获取该地址，需要使用**取地址符(&)**。因为引用不是对象，所以不能定义指向引用的指针。

```cpp
int ival = 42;
int *p = &ival;
```

除了 [2.4.2 节](#_242-指针和-const) 和15.2.3 节介绍的两种情况，所有指针的类型都要和它所指向的对象严格匹配。

```cpp
double dval;
double *pd = &dval; // 正确
double *pd2 = pd; // 正确

int *pi = pd; // 错误：指针 pi 的类型和 pd 的类型不匹配
pi = &dval; // 错误：试图把 double 型对象的地址赋给 int 型指针
```

#### 指针值

指针的值（即地址）应属于下列 4 种状态之一：

1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，意味着指针没有指向任何对象。
4. 无效指针，上述情况之外的其他值。

#### 利用指针访问对象

如果指针指向了一个对象，需使用 **解引用符(\*)** 来访问该对象。

```cpp
int ival = 42;
int *p = &ival;
cout << *p; // 输出 42
```

⚠️ 解引用操作仅适用于那些确实指向了某个对象的**有效指针**。

#### 空指针

空指针不指向任何对象，在试图使用一个指针之前可以首先检查它是否为空。生成空指针的方法有如下三种，它们是等价的：

```cpp
int *p1 = nullptr; // C++ 11 新标准引入的方法
int *p2 = 0;
// 需要先 #include <cstdlib>
int *p3 = NULL;
```

- `nullptr`可以被转换成任意其他的指针类型。
- `NULL` 是一个**预处理变量（preprocessor variable）**，预处理变量不属于命名空间`std`，它由**预处理器**负责管理，2.6.3节 将简单介绍预处理器相关知识。
- ⚠️ 把 int 变量直接赋给指针是错误的操作，即使该变量恰好等于0。
- ⚠️ 建议初始化所有的指针，并尽量等定义了对象之后再定义指向他的指针

#### 赋值和指针

给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。

#### 其他指针操作

- 任何非 0 指针对应的条件值都是`true`
- 如果两个指针**存放的地址**相同，则它们相等；反之它们不相等
- ⚠️ 一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相等的情况，这种情况通常发生在**数组或连续分配的对象**中：

     ```cpp
    struct Object {
        int data;
    };

    Object obj1;  // 对象1
    Object obj2;  // 对象2

    Object* ptr1 = &obj2;           // ptr1指向obj2
    Object* ptr2 = &obj1 + 1;       // ptr2指向obj1的下一地址

    // 如果obj1和obj2在内存中恰好是连续存储的
    // 那么 ptr1 == ptr2 就可能成立
    ```

#### void* 指针

`void*`是一种特殊的指针类型，可用于存放**任意对象**的地址，但不能直接操作该类型指针所指的对象。

#### 练习

##### 2.18

编写代码分别更改指针的值以及指针所指对象的值。

```cpp
int main()
{
    int i = 5, j = 10;
    int *p = &i;
    cout << p << " " << *p << endl;
    p = &j;
    cout << p << " " << *p << endl;
    *p = 20;
    cout << p << " " << *p << endl;
    j = 30;
    cout << p << " " << *p << endl;
    return EXIT_SUCCESS;
}
```

输出结果：

```plaintext
0x16ddfa5c8 5
0x16ddfa5c4 10
0x16ddfa5c4 20
0x16ddfa5c4 30
```

##### 2.19

说明指针和引用的主要区别。

1. 引用必须初始化，指针可以不初始化；
2. 引用不是对象，指针是一个对象；
3. 引用不能改变其绑定对象，指针可以更改其指向的地址，从而改变指向的对象。

##### 2.20

请叙述下面这段代码的作用：

```cpp
int i = 42;
int *p1 = &i;
*p1 = *p1 * *p1;
```

`p1`指向`i`对象，代码实际作用是让`i = 42 * 42`。

##### 2.21

请解释下述定义。在这些定义中有非法的吗？如果有，为什么？

```cpp
int i = 0;
```

(a) double\* dp = \&i; (b)int \*ip = i; (c) int \*p = \&i;

- (a) 非法，`dp`应该指向`double`类型的对象而不是`int`类型的
- (b) 非法，等号左侧是`int*`类型，右侧是`int`类型，应该用`&`取地址符来获取`i`的地址
- (c) 合法

##### 2.22

假设 p 是一个 int 型指针，请说明下述代码的含义。

```cpp
if (p) // ...
if (*p) // ...
```

第一句判断`p`指针的值：

- 如果`p`指针指向一个真实存在的变量，则其值必不为0，此时条件为真；
- 如果`p`指针为无效指针，此时条件为真，对`p`的使用将引发不可预计的结果；
- 如果`p`为0，则条件为假。

第二句判断`p`指针指向的 int 对象的值：

- 如果该值为0，条件为假；如果值不为0，条件为真。

##### 2.23

给定指针p，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，也请说明原因。

如果在**所有指针都初始化**的前提下，可以通过判断指针是否为`0`或`nullptr`来判断指针是否合法。否则，可以将`if(p)`置于`try...catch...`代码块中，如果程序块顺利进行，则表示指针合法，反之不合法。

##### 2.24

在下面这段代码中为什么p合法而lp非法？

```cpp
int i = 42;
void *p = &i;
long *lp = &i;
```

- `void*`指针可以指向任何类型的对象，而`lp`是一个长整型指针，`i`是一个整型对象，类型不符

### 2.3.3 理解复合类型的声明

#### 定义多个变量

涉及指针或引用的声明，一般有两种写法。

1. 把修饰符和变量标识符写在一起，着重强调**变量具有的复合类型**：

    ```cpp
    int *p1, *p2;
    ```

2. 把修饰符和类型名写在一起，并且每条语句只定义一个变量，着重强调**本次声明定义了一种复合类型**：

    ```cpp
    int *p1;
    int *p2;
    ```

#### 指向指针的指针

指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针中。

通过\*的个数可以区分指针的级别。也就是说，\*\*表示指向指针的指针，\*\*\*表示指向指针的指针的指针，以此类推。

![多重指针示意图](/images/20251030230436.png)

#### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```cpp
int i = 42;
int *p;         // p 是一个 int 型的指针
int *&r = p;    // r 是与指针 p 绑定的引用

r = &i;         // r = &i 等同于 p = &i
*r = 0;         // *r = 0 等同于 *p = 0
```

要理解`r`的类型，最有效的方法是**从右向左**阅读`r`的定义：

1. `r`左侧是`&`，表示`r`是一个引用
2. `&r`左侧是`*`，表示`r`是一个对指针的引用
3. `*&r`左侧是`int`，表示`r`是一个对int类型指针的引用

#### 练习

##### 2.25

说明下列变量的类型和值。

![题目 2.25](/images/20251030235015.png)

- (a) ip为int类型指针，值不确定；i为int类型变量，如果定义在块作用域内，值不确定；r为i的引用，值为不确定。
- (b) i为int类型变量，如果定义在块作用域内，值不确定；ip为空指针，值为0.
- (c) ip为int类型指针，值不确定；ip2为int类型变量，如果定义在块作用域内，值为不确定。

## 2.4 const 限定符

默认情况下，const 对象被设定为**仅在文件内有效**，如果需要一个 const 变量，它的初始值不是一个常量表达式，但又需要在文件间共享，就需要：*对于 const 变量不管是声明还是定义都添加 extern 关键字*：

```cpp
// file_1.cc定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
// file_1.h头文件
extern const int bufSize; // 与 file_1.cc 中定义的 bufSize 是同一个
```

### 2.4.1 const 的引用

把引用绑定到`const`对象上,称为**对常量的引用（reference to const）**,对常量的引用不能修改它绑定的对象:

```cpp
const int ci = 1024;
const int &r1 = ci; // 正确：引用及其对应的对象都是常量

r1 = 42; // 错误：r1是对常量的引用
int &r2 = ci; // 错误：试图让一个非常量引用指向一个常量对象
```

引用的对象是常量还是非常量可以决定其所能参与的操作，但不会影响到引用和对象的绑定关系本身。

#### 初始化和对const的引用

[2.3.1 节](#_231-引用) 提到，引用的类型必须与其所引用对象的类型一致，但有两个例外，这是第一个例外：

初始化**常量引用**时，允许使用**任意表达式**作为初始值，只要该表达式的结果能转换成引用的类型即可（参见[2.1.2 节](#_212-类型转换)：

```cpp
int i = 42;
const int &r1 = i;      // 允许将 const int& 绑定到一个普通 int 对象上
const int &r2 = 42;     // 正确
const int &r3 = r1 * 2; // 正确
int &r4 = r1 * 2;       // 错误：r4是一个普通的非常量引用
```

现在具体解释一下为什么`int &r4 = r1 * 2` 这种写法是非法的：

当使用一个常量引用来引用一个类型不匹配的对象时，编译器会创建一个**临时对象**来完成绑定：

```cpp
double dval = 3.14;
const int &ri = dval;
```

编译器实际会将代码转换为：

```cpp
const int temp = dval; // 创建一个临时的int常量，值为3（截断）
const int &ri = temp; // ri引用这个临时量
```

如果允许非常量引用绑定到临时量，会出现问题：

```cpp
int &r4 = ri * 2;
```

假设这样可以，程序员可能想通过 r4 修改 ri * 2 的结果，但临时对象马上就销毁了，修改毫无意义。这种行为很容易导致错误，所以**C++禁止非常量引用绑定到临时对象**。

#### 对 const 的引用可能引用一个并非 const 的对象

如果被绑定的对象不是一个 const，那么定义的引用可以是 const 或不是 const，如果引用是 const，那就不能通过该引用来修改绑定的对象：

```cpp
int i = 42;
int &r1 = i;
const int &r2 = i;
r1 = 0; // 正确
r2 = 0; // 错误
```

### 2.4.2 指针和 const
