---
date: 2025-10-27
title: 2. 变量和基本类型
description: 介绍了 C++ 的内置类型，了解 C++ 复杂数据类型
---

## 2.1 基本内置类型

### 2.1.1 算术类型

算术类型分为两类：整型和浮点型。

算术类型的尺寸在不同机器上有所差别。下表列出了 C++ 标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。

| Type | Meaning | Minimum Size |
|------|---------|--------------|
| bool | Boolean | N/A |
| char | Character | 8 bits |
| wchar_t | Wide character | 16 bits |
| char16_t | Unicode character | 16 bits |
| char32_t | Unicode character | 32 bits |
| short | Short integer | 16 bits |
| int | Integer | 16 bits |
| long | Long integer | 32 bits |
| long long | Long integer | 64 bits |
| float | Single-precision floating-point | 6 significant digits |
| double | Double-precision floating-point | 10 significant digits |
| long double | Extended-precision floating-point | 10 significant digits |

#### 字符类型

- 字符类型有多种，其中大多数是为了支持国际化而存在的。基本字符类型是 `char`。`char` 的大小保证足以容纳与机器基本字符集中的字符对应的数值。也就是说，`char` 的大小与**单个机器字节**相同。
- 其余字符类型——`wchar_t`、`char16_t` 和 `char32_t` ——用于扩展字符集。`wchar_t` 类型保证足够大，可以容纳机器最大扩展字符集中的任何字符。`char16_t` 和 `char32_t` 类型用于 `Unicode 字符`。

#### 其他整型

其余的整数类型表示（可能）不同大小的整数值。C++ 语言保证：

- int 至少与 short 大小相同
- long 至少与 int 大小相同
- long long 至少与 long 大小相同
- long long 类型是 C++ 11 标准引入的

#### 浮点类型

浮点类型表示单精度、双精度和扩展精度值。C++ 标准规定了有效数字的最小位数。大多数编译器提供的精度高于规定的最小值。通常：

- 浮点数（float）用一个字（32 位）表示
- 双精度数（double）用两个字（64 位）表示
- 长双精度数（long double）用三个或四个字（96 位或 128 位）表示

浮点数和双精度数通常分别产生约 7 位和 16 位有效数字。长双精度数通常用于兼容专用浮点硬件；其精度在不同实现之间可能存在差异。

#### 带符号类型和无符号类型

除去布尔型和扩展的字符型之外，其他整型可以划分为**带符号的（signed）** 和 **无符号的（unsigned）**。

与其他整型不同，字符型被划分为了三种：char、signed char 和 unsigned char。尽管字符型有三种，但字符的表现形式只有两种：带符号的和无符号的。类型 char 实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。

#### 建议：如何选择类型

- 当明确知晓数值不可能为负时，选用无符号类型；
- 使用int执行整数运算。如果数值超过了int的表示范围，选用long long；
- 在**算术表达式**中不要使用char或bool，如果需要一个不大的整数，要明确指定它的类型是signed char/unsigned char；
- 执行浮点运算用double，float和double的计算代价相差无几，对某些机器来说，double运算速度比float还快。

#### 练习

##### 2.1 类型int、long、long long和 short 的区别是什么？无符号类型和带符号类型的区别是什么？float 和 double 的区别是什么？

*我的回答*

1. int 至少与 short 大小相同；long 至少与 int 大小相同；long long 至少与 long 大小相同
2. 无符号类型大于等于0，带符号类型可小于、等于和大于0
3. float用一个字表示，double用两个字表示；float有效数位为7，double有效数位为17

*Claude修正后的回答*

1. int、long、long long 和 short 的区别

    **C++标准保证的最小尺寸要求：**

    - `short` 至少16位（2字节）
    - `int` 至少16位（2字节）
    - `long` 至少32位（4字节）
    - `long long` 至少64位（8字节）（C++11引入）

    **尺寸关系保证：**

    ```plaintext
    short ≤ int ≤ long ≤ long long
    ```

    **常见实现（取决于平台）：**

    - 32位系统：`short`(2字节)，`int`(4字节)，`long`(4字节)，`long long`(8字节)
    - 64位系统：`short`(2字节)，`int`(4字节)，`long`(4或8字节)，`long long`(8字节)

2. 无符号类型和带符号类型的区别

   - **带符号类型（signed）**：可以表示负数、零和正数，最高位为符号位
   - **无符号类型（unsigned）**：只能表示零和正数（≥0），所有位都用于表示数值

   **关键区别：**

   - 相同字节数下，无符号类型能表示的最大正数约为带符号类型的两倍
   - 例如：`unsigned int`(0 到 4,294,967,295) vs `int`(-2,147,483,648 到 2,147,483,647)

3. float 和 double 的区别

    | 特性 | float | double |
    |------|-------|--------|
    | **存储大小** | 4字节（32位） | 8字节（64位） |
    | **有效数字位数** | 约6-7位十进制数字 | 约15-16位十进制数字 |
    | **精度** | 单精度 | 双精度 |
    | **指数范围** | 约10^(-38)到10^(38) | 约10^(-308)到10^(308) |

    **术语说明：**

    - "字（word）"是一个与处理器架构相关的概念，在不同系统上大小不同
    - 更准确的表述应使用"字节（byte）"作为单位

    **建议：**

    - 一般情况下优先使用`double`，因为精度更高且现代处理器对double的运算效率与float相当
    - 只在内存受限或需要大量浮点数存储时考虑使用`float`

##### 2.2 计算按揭贷款时，对千利率、本金和付款分别应选择何种数据类型？说明你的理由

1. 利率：double

    - 利率为小数（如0.0525或5.25%）
    - 需要较高精度避免复利计算中的累积误差

2. 本金：double

    - 金额可能有小数（精确到分）
    - 数值范围在double表示范围内
    - 需要与利率进行浮点运算

3. 付款：double

    - 月供金额通常有小数
    - 由本金和利率计算得出，保持类型一致避免转换
    - 便于后续财务计算

### 2.1.2 类型转换

#### 转换准则

- 当我们将一个**非布尔值**的算术类型赋给一个 `bool` 对象时，如果原值是 0，则结果为 `false`，否则为 `true`。
- 当我们将一个 `bool` 值赋给一个**非 `bool` 值**的算术类型时，如果 `bool` 值为 `true`，则结果为 1，如果为 `false`，则结果为 0。
- 当我们将一个**浮点型**值赋给一个**整型**对象时，该值会被**截断** (truncated)。存储的值是小数点前的部分。
- 当我们将一个**整型**值赋给一个**浮点型**对象时，小数部分为零。如果该整数的位数（比特）超过了浮点型对象所能容纳的范围，可能会**损失精度**。
- 如果我们给一个**无符号类型** (unsigned) 的对象赋了一个超出其范围的值，结果是该值对该类型可容纳值的总数**取模** (modulo) 后的余数。例如，一个 8 位的 `unsigned char`（范围 0-255）被赋予 -1，其结果将是 -1 对 256 取模，即 255。
- 如果我们给一个**有符号类型** (signed) 的对象赋了一个超出其范围的值，其结果是**未定义的** (undefined)。程序可能看起来能工作，也可能会崩溃，或者产生垃圾值。

#### 含有无符号类型的表达式

当一个算术表达式中既有**无符号数**又有**有符号数**时，有符号数会被转换为无符号数：

```cpp
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl; // 输出 -84
std::cout << i + u << std::endl; // 如果 int 占 32 位，输出 (10-42) % 2^32 = 4294867264
```

当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值：

```cpp
unsigned ul = 42, u2 = 10;
std::cout << ul - u2 << std::endl; //正确：检出32
std::cout << u2 - ul << std::endl; //正确：不过，结果是取模后的值，输出 (10-42) % 2^32 = 4294867264
```

🪤 陷阱：

```cpp
for (int i = 10; i >= 0; --i)
    std::cout << i << std::endl;
```

这段函数是为了从10到0降序输出，但如果将`i`设置为无符号数，那在`i==0`后，进行`--i`操作，`i`将被赋值为 $-1 \bmod 2^{32} = 2^{32} -1 = 4,294,967,295$。

#### 练习

##### 2.3 & 2.4 读程序写结果

```cpp
unsigned u = 10, u2 = 42;
std::cout << u2 - u << std::endl; // 1
std::cout << u - u2 << std::endl;// 2
int i = 10, i2 = 42;
std::cout << 12 -i << std::endl; // 3
std::cout << i - i2 << std::endl; // 4
std::cout << i - u << std::endl; // 5
std::cout << u - i << std::endl; // 6
```

预测答案：

- [x] 1. 32
- [x] 2. 4294867264
- [x] 3. 2
- [x] 4. -32
- [x] 5. 0
- [x] 6. 0

### 2.1.3 字面量常量

#### 整型和浮点型字面值

整型字面值可写作十进制数、八进制数或十六进制数的形式。以 `0` 开头的整数代表八进制数，以 `Ox` 或 `0X` 开头的代表十六进制数。

默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。

- 十进制字面值的类型是 int long 和 long long 中**尺寸最小**的那个；
- 类型 short 没有对应的字面值；
- 八进制和十六进制字面值的类型是能容纳其数值的 int、unsigned int、long、unsigned long、long long 和 unsigned long long 中**尺寸最小**的那个；
- 如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用 E 或 e 标识：

```plaintext
3.14159 3.14159EO 0. OeO .001
```

#### 字符和字符串字面值

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式：

```cpp
std::cout << "hello hello hello"
        "World!" << std::endl;
```

#### 转义序列

有两类字符程序员不能直接使用：一类是不可打印（ nonp ri ntable) 的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单引号、双引号、问号、反斜线）。

C++语言规定的转义序列包括：

|  |  |   |   |
| ---- | ---- | ---- | ---- |
| 换行符 | \n | 双引号 | \" |
| 横向制表符 | \t | 单引号 | \' |
| 报警（响铃）符 | \a | 反斜线 | \\ |
| 纵向制表符 | \v | 问号 | \? |
| 退格符 | \b | 回车符 | \r |
| 进纸符 | \f | | |

我们也可以使用泛化的转义序列，其形式是＼x 后紧跟 1个或多个十六进制数字，或者＼后紧跟 1 个、2 个或3 个八进制数字，其中数字部分表示的是字符对应的数值。假设使用的是 Latin-1 字符集，以下是一些示例：

|    |    |    |
| -- | -- | -- |
|\7（响铃）|\12（换行符）|\40（空格）|
|\0（空字符）|\115（字符M）|\x4d（字符M）|

![指定字面值的类型](/images/20251028195503.png)

#### 布尔字面值和指针字面值

- 布尔字面值：true 和 false
- 指针字面值：nullptr

#### 练习

##### 2.5

![练习2.5](/images/20251028195658.png)

(a)

|字面值|数据类型|描述|
|-|-|-|
|'a'|char|占一个字节|
|L'a'|wchar_t|长字符，占两个字节|
|"a"|const char[2]|占两个字节，第一个字节内容为'a'，第二个字节内容为'\0'|
|L"a"|const wchar_t[2]|占四个字节，第一个字节内容为L'a'，第二个字节内容为L'\0'|

(b)

|字面值|数据类型|描述|
|-|-|-|
|10|int||
|10u|unsigned int||
|10L|long||
|10uL|unsigned long||
|012|int|八进制数，表示为十进制的10|
|0xc|int|十六进制数，表示为十进制的12 |

(c)

|字面值|数据类型|描述|
|-|-|-|
|3.14|double|双精度浮点数|
|3.14f|float|单精度浮点数|
|3.14L|long double|长双精度浮点数|

(d)

|字面值|数据类型|描述|
|-|-|-|
|10|int||
|10u|unsigned int||
|10.|double|浮点数，等价于10.0|
|10e-2|double|科学计数法|

##### 2.6

![练习2.6](/images/20251028195716.png)

有区别

1. 第一行是将十进制整型字面量赋值给`month`和`day`。
2. 第二行的字面量为八进制格式，但`month`赋值为`09`不对，会产生编译错误，应该赋值为`011`。

##### 2.7

![练习2.7](/images/20251028195731.png)

- (a) 字符串，用到了转义序列，具体值为 "Who goes with Fergus?"，最后的`\012`表示一个换行符
- (b) 科学计数法表示的 long double 类型，值为 31.4
- (c) float 类型，值为1024.0
- (d) long double 类型，值为3.14

##### 2.8

![练习2.8](/images/20251028195748.png)

```cpp
#include <iostream>

int main()
{
    std::cout << "2M" << std::endl;
    std::cout << 2 << '\t' << 'M' << std::endl;
    return EXIT_SUCCESS;
}
```

## 2.2 变量

### 2.2.1 变量定义

- 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值抹除，而以一个新值未替代。
- 初始化的四种方式：
  - int units_sold = 0;
  - int units_sold = {0}; // 列表初始化
  - int units_sold{0}; // 列表初始化
  - int units_sold(0);
  
  需注意的是，列表初始化在用于**内置类型**的变量时，如果初始值有丢失信息的风险，编译器会报错：
  - long double ld = 3.1415;
  - int a{ld}, b = {ld}; // 报错，向下取整导致的信息丢失
  - int c(ld), c = ld; // 不报错，虽然丢失信息，但没有使用列表初始化
- 默认初始化
  - 若一个内置类型的变量定义于任何函数体之外，它会被初始化为0；
  - 定义在函数内部的内置类型变量不会被初始化，一个未初始化的值是**未定义**的，如果试图拷贝或访问它将引发错误；
  - 类的对象如果没有显式地初始化，则其值由类确定。

#### 练习

##### 2.9

![题目2.9](/images/20251030151659.png)

- (a) **定义非法**，在 C++ 中，不能在输入流操作符 `>>` 的右侧同时进行变量声明和读取。输入操作符期望的是一个已存在的左值。
- (b) **定义非法**，使用列表初始化（list initialization）时，C++11 及以后的标准不允许窄化转换（narrowing conversion）。将 `double` 类型的 `3.14` 转换为 `int` 会丢失小数部分，属于窄化转换，因此编译器会报错。
- (c) **定义非法**，变量 `wage` 在使用前未声明。此语句试图将 `9999.99` 赋值给未定义的 `wage`，然后再将结果赋给 `salary`，应该修正为`double wage = 9999.99, salary = wage;`。
- (d) **定义正确**，这是传统的拷贝初始化（copy initialization），允许隐式类型转换。3.14 会被截断为 3，赋值给 i。这种写法在 C++ 中是合法的，但会导致精度丢失（编译器可能会给出警告）。

##### 2.10

![题目2.10](/images/20251030151716.png)

- `std::string global_str`: 空字符串，`std::string`是类类型，如果没有显式初始化，则其值由此类的无参构造函数决定。
- `int global_int`: 声明在所有函数体外，默认初始化为0。
- `int local_int`: 声明在函数体内，不进行初始化，值是未定义的(通常是内存中的随机值)。
- `std::string local_str`: 空字符串，`std::string`是类类型，如果没有显式初始化，则其值由此类的无参构造函数决定。

### 2.2.2 变量声明和定义的关系

如果想在多个文件中使用同一变量，就需要将变量声明和定义分开来：

- 在一个文件中定义变量
- 在用到该变量的文件中声明变量（不可重复定义该变量）

使用方法：

- 定义变量：`double pi = 3.14;`
- 声明变量：`extern double pi;`
- 用`extern`关键字声明的变量也可以加上`=`来定义它的值，但这就变成了定义变量而不是声明变量
- 若在**函数题内部**试图**初始化**一个由`extern`关键字标记的变量，将引发错误：
  
  ```plaintext
  test.cpp:8:16: error: declaration of block scope identifier with linkage cannot have an initializer
    8 |     extern int extern_i = 3;
      |                ^
    1 error generated.
  ```

#### 练习

##### 2.11

![题目2.11](/images/20251030154324.png)

- (a) **定义**：虽然使用了 extern 关键字,但因为同时进行了初始化(= 1024),这会抵消 extern 的作用。任何包含了显式初始化的声明都是定义,即使带有 extern。因此，这是一个定义，而不是单纯的声明。
- (b) **定义**：这是一个没有 extern 关键字的普通变量声明。对于全局作用域(假设这些语句在函数外部),这既是声明也是定义。变量 iy 会被分配存储空间并默认初始化为 0。
- (c) **声明**：使用了 extern 关键字且没有初始化。这是一个纯声明,表示变量 iz 在其他地方定义。这个语句只是告诉编译器 iz 的类型和存在性,但不为其分配存储空间。

### 2.2.3 标识符

- C++的标识符(identifier) 由**字母、数字和下画线**组成，且必须以**字母或下划线**开头。
- 用户自定义的标识符中不能**连续出现两个下划线**，也不能以**下划线紧连大写字母**开头。此外，定义在**函数体外的标识符**不能以下划线开头。

变量命名规范：

- 标识符要能体现实际含义。
- 变量名一般用小写字母，如 index, 不要使用 Index 或 INDEX。
- 用户自定义的类名一般以大写字母开头，如Sales_item。
- 如果标识符由多个单词组成，则单词间应有明显区分，如 student_loan 或studentLoan, 不要使用studentloan。

![表2.3 C++关键字](/images/20251030155138.png)
![表2.4 C++操作符替代名](/images/20251030155201.png)

#### 练习

##### 2.12

![练习2.12](/images/20251030155241.png)

- (a) 非法，标识符不能和关键字重名
- (b) 合法
- (c) 非法，标识符只能包含下划线、字母和数字，不能包含运算符
- (d) 非法，标识符必须以下划线或字母开头，不能以数字开头
- (e) 合法，标识符大小写敏感，Double不是关键字

### 2.2.4 作用域

以下例进行说明：

```cpp
#include <iostream>
// 该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量

int reused = 42; // reused 拥有全局作用域
int main(){
    int unique = 0; // unique 拥有块作用域
    std::cout < reused << " " << unique << std::endl; // 输出#1：使用全局变量 reused；输出 42 0
    int reused = 0; // 新建局部变量 reused，覆盖了全局变量 reused
    std::cout << reused << " " < unique << std::endl; // 输出#2：使用局部变量 reused；输出0
    std::cout << ::reused << " " < unique << std::endl; // 输出#3：显式地访问全局变量  reused；输出 42 0
    return 0;
}
```

作用域分为：全局作用域和块作用域。

- 全局作用域：定义在所有函数体之外的作用域；
- 块作用域：定义在花括号`{}`内的作用域。

也可按相对关系分为：

- 内层作用域
- 外层作用域

内层作用域能访问外层作用域定义的所有名字，也能重新定义外层作用域中存在的名字。

因为全局作用域本身并没有名字，所以当作用域操作符`::`的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。

#### 练习

##### 练习 2.13

![练习 2.13](/images/20251030162021.png)

在 main 函数内部:

- 局部变量 int i = 100，定义在函数作用域内，**隐藏**了全局作用域的 `i = 42`
- 根据作用域规则，在内层作用域中，如果有同名变量，会优先使用内层的变量
- 因此 `int j = i;` 使用的是局部变量 `i`,其值为 `100`

![练习 2.14](/images/20251030162029.png)

程序合法，但输出不是期望的结果，在`for`语句中定义的`i`在离开`for`语句定义的代码块后便失效，因此打印出来的是`100 45`。

## 2.3 复合类型
